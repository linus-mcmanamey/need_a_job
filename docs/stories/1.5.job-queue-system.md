# Story 1.5: Job Queue System

## Status
Planned

**Started:** 2025-10-28
**Branch:** feature/story-1-5

## Story
**As a** system,
**I want to** implement a Redis-based job queue with RQ workers,
**so that** discovered jobs can be processed asynchronously by the agent pipeline.

## Acceptance Criteria

### AC 1: Redis Queue Created (REQ-004)
- [ ] Queue named `job_processing_queue` created in Redis
- [ ] Redis connection module with connection pooling
- [ ] Configuration loaded from environment variables (REDIS_URL, REDIS_HOST, REDIS_PORT)
- [ ] Connection health check and retry logic
- [ ] Graceful connection failure handling

### AC 2: RQ Worker Configuration
- [ ] RQ worker process configured and documented
- [ ] Worker startup script created (`scripts/run_worker.py`)
- [ ] Worker can be started with: `python -m rq worker job_processing_queue`
- [ ] Worker logs startup, job execution, and shutdown events
- [ ] Multiple worker instances supported (concurrency)

### AC 3: Job Enqueue Function
- [ ] `enqueue_job(job_id: UUID)` function created
- [ ] Takes job_id as input parameter
- [ ] Enqueues job for agent pipeline processing
- [ ] Returns job metadata (job_id, queue_position, estimated_wait_time)
- [ ] Validates job exists in database before enqueuing
- [ ] Updates application_tracking status to 'queued'
- [ ] Logs enqueue events with job metadata

### AC 4: Worker Job Pickup
- [ ] Worker automatically picks up jobs from queue
- [ ] Jobs processed in FIFO order (First In First Out)
- [ ] Worker fetches job details from database using job_id
- [ ] Worker executes job processing task
- [ ] Worker updates application_tracking.status during processing
- [ ] Worker logs job start, progress, and completion

### AC 5: Idempotent Job Tasks
- [ ] Jobs can be safely retried without side effects
- [ ] Database operations use transactions for atomicity
- [ ] Status checks prevent duplicate processing
- [ ] Generated files include job_id in filename to avoid conflicts
- [ ] Cleanup logic for partially completed jobs

### AC 6: Task Failure Handling
- [ ] Failed jobs captured with error details
- [ ] Failed jobs returned to queue with retry count
- [ ] Max retry limit: 3 attempts
- [ ] Exponential backoff between retries (5s, 15s, 45s)
- [ ] Dead letter queue (`failed_jobs`) for permanently failed jobs
- [ ] Error information stored in application_tracking.error_info
- [ ] Failed job notification/logging mechanism

### AC 7: Worker Status Monitoring
- [ ] Number of active workers queryable
- [ ] Queue depth (pending jobs) exposed via API/dashboard
- [ ] Processing rate (jobs/minute) calculated and logged
- [ ] Worker heartbeat mechanism
- [ ] Job execution time metrics collected
- [ ] Failed job count tracked

### AC 8: Worker Management Scripts
- [ ] Start worker script: `scripts/run_worker.py`
- [ ] Stop worker gracefully (SIGTERM handler)
- [ ] Monitor queue script: `scripts/monitor_queue.py`
- [ ] Clear queue script (for testing): `scripts/clear_queue.py`
- [ ] Retry failed jobs script: `scripts/retry_failed_jobs.py`

## Implementation Plan

### File Structure
```
app/
  queue/
    __init__.py              # Package initialization
    job_queue.py             # JobQueue class (enqueue, monitor)
    worker_tasks.py          # Worker task definitions
    redis_client.py          # Redis connection management
  services/
    job_processor.py         # JobProcessorService (orchestrates agents)
scripts/
  run_worker.py              # Start RQ worker
  monitor_queue.py           # Queue monitoring CLI
  clear_queue.py             # Clear queue (testing)
  retry_failed_jobs.py       # Retry failed jobs
tests/
  unit/
    queue/
      __init__.py
      test_job_queue.py      # Unit tests for queue operations
      test_worker_tasks.py   # Unit tests for worker tasks
  integration/
    queue/
      __init__.py
      test_queue_integration.py  # End-to-end queue tests
```

### Core Components

#### 1. Redis Client Module (`app/queue/redis_client.py`)

**Responsibilities:**
- Establish Redis connection with connection pooling
- Load Redis configuration from environment
- Provide health check and retry logic
- Expose singleton Redis client

**Key Functions:**
- `get_redis_connection() -> Redis` - Get Redis connection with pooling
- `check_redis_health() -> bool` - Ping Redis to verify connectivity
- `close_redis_connection()` - Clean shutdown

#### 2. JobQueue Class (`app/queue/job_queue.py`)

**Responsibilities:**
- Enqueue jobs for processing
- Monitor queue status and metrics
- Manage failed jobs and dead letter queue

**Key Methods:**
- `enqueue_job(job_id: UUID) -> Job` - Enqueue job with validation
- `get_queue_depth() -> int` - Number of pending jobs
- `get_active_workers() -> int` - Number of running workers
- `get_failed_jobs() -> List[Job]` - Retrieve failed jobs
- `retry_job(job_id: UUID)` - Retry a failed job
- `clear_queue()` - Clear all pending jobs (testing only)

#### 3. Worker Tasks (`app/queue/worker_tasks.py`)

**Responsibilities:**
- Define RQ worker task functions
- Execute job processing pipeline
- Handle errors and retries

**Key Functions:**
- `process_job(job_id: str) -> Dict` - Main worker task
  * Fetches job from database
  * Updates status to 'processing'
  * Calls JobProcessorService (Epic 2)
  * Updates status based on result
  * Returns processing result
- `on_failure(job, connection, type, value, traceback)` - RQ failure callback
- `on_success(job, connection, result)` - RQ success callback

#### 4. JobProcessorService (`app/services/job_processor.py`)

**Responsibilities:**
- Orchestrate agent pipeline execution (placeholder for Epic 2)
- Coordinate checkpoint/resume system
- Manage agent state transitions

**Key Methods (Stub for Story 1.5):**
- `process_job(job_id: UUID) -> ProcessingResult` - Execute agent pipeline
  * For Story 1.5: Returns mock success result
  * Epic 2: Will implement full agent pipeline
- `get_processing_status(job_id: UUID) -> Dict` - Get current processing status

### Configuration

**Environment Variables (`.env`):**
```bash
# Redis Configuration
REDIS_URL=redis://localhost:6379
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0
REDIS_PASSWORD=  # Optional

# RQ Configuration
RQ_QUEUE_NAME=job_processing_queue
RQ_FAILED_QUEUE=failed_jobs
RQ_JOB_TIMEOUT=600  # 10 minutes
RQ_RESULT_TTL=86400  # 24 hours
RQ_MAX_RETRIES=3
RQ_RETRY_DELAYS=5,15,45  # Exponential backoff in seconds
```

**Docker Compose Configuration:**
- Redis service already configured (port 6379)
- Worker service defined with 3 replicas
- RQ Dashboard service (optional monitoring)

### Queue Architecture

**Job Flow:**
```
LinkedIn Poller → Database (jobs table)
                     ↓
              enqueue_job()
                     ↓
         Redis Queue (job_processing_queue)
                     ↓
              RQ Worker (picks up job)
                     ↓
         process_job(job_id) task
                     ↓
         JobProcessorService (agents in Epic 2)
                     ↓
         Update application_tracking status
                     ↓
         Success: status='processed'
         Failure: Retry → Dead Letter Queue (after 3 attempts)
```

**Retry Strategy:**
- Attempt 1: Immediate
- Attempt 2: Wait 5 seconds
- Attempt 3: Wait 15 seconds
- Attempt 4: Wait 45 seconds
- After 3 retries: Move to `failed_jobs` queue

**Dead Letter Queue:**
- Failed jobs moved to `failed_jobs` queue
- Error details stored in application_tracking.error_info
- Manual review and retry available via script

### Worker Management

**Starting Workers:**
```bash
# Single worker
python scripts/run_worker.py

# Multiple workers (separate terminals or use docker-compose)
python scripts/run_worker.py --name worker-1
python scripts/run_worker.py --name worker-2
python scripts/run_worker.py --name worker-3

# Via RQ directly
python -m rq worker job_processing_queue --name worker-1

# Via Docker Compose (3 workers)
docker-compose up worker
```

**Monitoring:**
```bash
# Queue status
python scripts/monitor_queue.py

# RQ info (requires rq)
rqinfo

# RQ Dashboard (web UI)
docker-compose --profile monitoring up rq-dashboard
# Visit: http://localhost:9181
```

**Clearing Queue (Testing):**
```bash
python scripts/clear_queue.py --confirm
```

**Retrying Failed Jobs:**
```bash
# Retry all failed jobs
python scripts/retry_failed_jobs.py --all

# Retry specific job
python scripts/retry_failed_jobs.py --job-id <uuid>
```

### Testing Requirements

**Unit Tests (`tests/unit/queue/test_job_queue.py`):**
- [ ] Test Redis connection establishment
- [ ] Test job enqueue with valid job_id
- [ ] Test job enqueue with invalid job_id (validation)
- [ ] Test get_queue_depth() returns correct count
- [ ] Test get_active_workers() returns correct count
- [ ] Test get_failed_jobs() retrieves failed jobs
- [ ] Mock Redis operations
- [ ] Target: 90%+ code coverage

**Unit Tests (`tests/unit/queue/test_worker_tasks.py`):**
- [ ] Test process_job() with valid job_id
- [ ] Test process_job() with invalid job_id
- [ ] Test idempotent behavior (multiple calls same job)
- [ ] Test failure callback stores error info
- [ ] Test success callback updates status
- [ ] Test retry logic with max retry limit
- [ ] Mock database and JobProcessorService
- [ ] Target: 90%+ code coverage

**Integration Tests (`tests/integration/queue/test_queue_integration.py`):**
- [ ] End-to-end: Enqueue job → Worker processes → Database updated
- [ ] Test with real Redis (test container)
- [ ] Test multiple workers processing concurrently
- [ ] Test retry mechanism with failed jobs
- [ ] Test dead letter queue for max retries exceeded
- [ ] Test queue metrics accuracy
- [ ] Test worker graceful shutdown

**Manual Testing:**
- [ ] Start Redis: `docker-compose up redis -d`
- [ ] Start worker: `python scripts/run_worker.py`
- [ ] Enqueue test job via Python script or FastAPI endpoint (Epic 5)
- [ ] Verify worker processes job
- [ ] Check application_tracking.status updated
- [ ] Monitor queue with `python scripts/monitor_queue.py`
- [ ] Test failure scenario (mock error in processor)
- [ ] Verify retry and dead letter queue behavior

### Performance Considerations

**Metrics to Track:**
- Job enqueue time (target: <100ms)
- Worker job pickup latency (target: <1 second)
- Job processing time (varies by agent pipeline in Epic 2)
- Queue depth over time
- Worker throughput (jobs/minute)
- Failed job rate

**Optimization Opportunities:**
- Worker concurrency: Start with 3 workers, scale to 10+ if needed
- Redis connection pooling: Reuse connections
- Batch enqueue for multiple jobs (future enhancement)
- Priority queues for high-value jobs (future enhancement)

### Security Considerations

- Redis password authentication (if required in production)
- Network isolation (Redis not exposed to public internet)
- Job data validation before processing
- Rate limiting on enqueue operations (prevent queue flooding)
- Access control for management scripts (retry, clear)
- No sensitive data in job parameters (use job_id reference)

## Technical Notes

**RQ Library:**
- Simple Python-based task queue
- Built on Redis for reliability
- Supports multiple queues, priorities, and scheduling
- Integrates with Flask/FastAPI easily

**Redis Configuration:**
- Persistence enabled (appendonly yes) for durability
- Connection pooling for performance
- Health checks for monitoring

**Worker Concurrency:**
- Start with 3 workers (docker-compose replicas: 3)
- Scale up based on queue depth and processing time
- Each worker handles 1 job at a time (sequential per worker)

**Integration with Epic 2 (Agents):**
- Story 1.5: JobProcessorService is a stub (returns mock success)
- Epic 2: JobProcessorService will orchestrate 7 agents in sequence
- Epic 2: Checkpoint/resume system for long-running jobs
- Epic 2: Agent output stored in application_tracking.stage_outputs

**Integration with Story 1.4 (Poller):**
- LinkedIn poller can optionally enqueue jobs after insertion
- Configuration: `ENABLE_AUTO_ENQUEUE=true`
- Future: Poller → Database → Auto-Enqueue → Queue → Worker

## Dependencies

**From Previous Stories:**
- Story 1.1: FastAPI app structure, dependencies ✅
- Story 1.2: Configuration system ✅
- Story 1.3: Database schema, ApplicationRepository ✅
- Story 1.4: LinkedIn poller (can trigger enqueue) ✅

**External Dependencies:**
- Redis server (docker-compose or local)
- RQ library (already installed)
- Python packages: redis, rq, loguru

**New Dependencies:**
- None (all already in requirements.txt)

## Definition of Done

- [ ] Redis client module implemented and tested
- [ ] JobQueue class implemented with enqueue and monitoring
- [ ] Worker tasks defined with process_job() function
- [ ] RQ worker configured and runnable
- [ ] Worker management scripts functional
- [ ] Job enqueue validates and updates database
- [ ] Worker processes jobs and updates status
- [ ] Retry logic implemented with max retries
- [ ] Dead letter queue operational
- [ ] Queue monitoring metrics available
- [ ] Unit tests: 90%+ coverage
- [ ] Integration tests: End-to-end flow validated
- [ ] Error scenarios tested (connection failures, retries)
- [ ] Manual testing: Worker runs and processes jobs
- [ ] Code review approved (architecture, security, quality)
- [ ] Documentation complete (this file + docstrings)
- [ ] PR created and merged to main

## QA Test Plan

### Test Scenarios

**Scenario 1: Basic Job Enqueue and Process**
1. Start Redis
2. Enqueue job with valid job_id
3. Start worker
4. Verify worker picks up and processes job
5. Check application_tracking.status updated to 'processed'
6. Verify logs show job execution

**Scenario 2: Job Validation**
1. Attempt to enqueue job with invalid job_id
2. Expect validation error
3. Verify job not added to queue

**Scenario 3: Retry Logic**
1. Mock JobProcessorService to raise exception
2. Enqueue job
3. Worker attempts job
4. Verify retry with exponential backoff (5s, 15s, 45s)
5. After 3 retries, verify job moved to failed_jobs queue
6. Check error_info stored in application_tracking

**Scenario 4: Concurrent Workers**
1. Enqueue 10 jobs
2. Start 3 workers
3. Verify all jobs processed concurrently
4. Check no duplicate processing (idempotent)
5. Verify queue depth decreases as jobs complete

**Scenario 5: Worker Graceful Shutdown**
1. Enqueue job with long processing time
2. Worker starts processing
3. Send SIGTERM to worker
4. Verify worker finishes current job before shutdown
5. Verify job not marked as failed

**Scenario 6: Queue Monitoring**
1. Enqueue 5 jobs
2. Run monitoring script
3. Verify queue depth = 5
4. Start workers
5. Monitor queue depth decreasing
6. Verify metrics: active workers, processing rate

**Scenario 7: Dead Letter Queue Management**
1. Enqueue job that will fail after max retries
2. Verify job moves to failed_jobs queue
3. Run retry script to re-enqueue failed job
4. Verify job re-enters job_processing_queue

### Acceptance Criteria Validation

For each AC, QA will:
- Execute relevant test scenarios
- Document results (PASS/FAIL)
- Capture logs and screenshots
- Verify database state changes
- Check error handling

## Architecture Review Checklist

- [ ] Clean architecture with dependency injection
- [ ] Repository pattern used for database access
- [ ] Configuration externalized (environment variables)
- [ ] Error handling comprehensive with retries
- [ ] Logging at appropriate levels
- [ ] Type hints throughout
- [ ] Docstrings on all classes and methods
- [ ] Security best practices (no hardcoded credentials)
- [ ] Performance considerations addressed
- [ ] Integration points with Stories 1.3, 1.4 clear
- [ ] Foundation for Epic 2 (agent pipeline) established

## Story Retrospective
*To be filled by SM Agent after merge*
