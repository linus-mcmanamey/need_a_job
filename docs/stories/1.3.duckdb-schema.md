# Story 1.3: DuckDB Schema Implementation

## Status
In Progress

## Story
**As a** system,
**I want** to implement the DuckDB schema with jobs and application tracking tables,
**so that** I can store and query job data efficiently.

## Acceptance Criteria
1. `jobs` table created with schema (REQ-012):
   - job_id (PK, UUID)
   - platform_source (linkedin|seek|indeed)
   - company_name (VARCHAR)
   - job_title (VARCHAR)
   - job_url (VARCHAR, UNIQUE)
   - salary_aud_per_day (DECIMAL, nullable)
   - location (VARCHAR)
   - posted_date (DATE)
   - job_description (TEXT)
   - requirements (TEXT)
   - responsibilities (TEXT)
   - discovered_timestamp (TIMESTAMP)
   - duplicate_group_id (UUID, nullable)

2. `application_tracking` table created with schema (REQ-012):
   - application_id (PK, UUID)
   - job_id (FK -> jobs.job_id)
   - status (ENUM: discovered|matched|documents_generated|ready_to_send|sending|completed|pending|failed|rejected|duplicate)
   - current_stage (VARCHAR: agent name)
   - completed_stages (JSON: array of agent names)
   - stage_outputs (JSON: agent outputs)
   - error_info (JSON: stage, error_type, error_message, timestamp)
   - cv_file_path (VARCHAR, nullable)
   - cl_file_path (VARCHAR, nullable)
   - submission_method (ENUM: email|web_form, nullable)
   - submitted_timestamp (TIMESTAMP, nullable)
   - contact_person_name (VARCHAR, nullable)
   - created_at (TIMESTAMP)
   - updated_at (TIMESTAMP)

3. Indexes created for common queries:
   - job_url (unique index)
   - platform_source + posted_date
   - application_tracking.status
   - application_tracking.job_id

4. Database initialization script created (`init_db.py`)
5. Database connection module created with connection pooling
6. Basic CRUD operations implemented for both tables
7. Migration system (optional but recommended) for schema changes

## Tasks / Subtasks

- [ ] Create database module structure (AC: 4, 5)
  - [ ] Create app/repositories/__init__.py
  - [ ] Create app/repositories/database.py with connection management
  - [ ] Implement get_connection() function with thread-safe access
  - [ ] Add database initialization check
  - [ ] Configure database path from config (data/jobs.duckdb)
  - [ ] Add connection pooling or singleton pattern

- [ ] Define database schema (AC: 1, 2)
  - [ ] Create app/repositories/schema.py
  - [ ] Define jobs table schema with all columns
  - [ ] Define application_tracking table schema with all columns
  - [ ] Define platform_source ENUM values
  - [ ] Define application status ENUM values
  - [ ] Define submission_method ENUM values
  - [ ] Add foreign key constraints
  - [ ] Document JSON column structures

- [ ] Implement database initialization (AC: 4)
  - [ ] Create scripts/init_db.py
  - [ ] Implement create_tables() function
  - [ ] Implement create_indexes() function (AC: 3)
  - [ ] Add database existence check
  - [ ] Add table existence check
  - [ ] Add CLI interface for initialization
  - [ ] Support --reset flag to drop and recreate

- [ ] Create CRUD operations for jobs table (AC: 6)
  - [ ] Create app/repositories/jobs_repository.py
  - [ ] Implement insert_job(job_data) -> job_id
  - [ ] Implement get_job_by_id(job_id) -> Job
  - [ ] Implement get_job_by_url(job_url) -> Job
  - [ ] Implement update_job(job_id, updates)
  - [ ] Implement delete_job(job_id)
  - [ ] Implement list_jobs(filters, limit, offset) -> List[Job]
  - [ ] Add type hints for all functions
  - [ ] Return domain models (not raw dicts)

- [ ] Create CRUD operations for application_tracking table (AC: 6)
  - [ ] Create app/repositories/application_repository.py
  - [ ] Implement insert_application(application_data) -> application_id
  - [ ] Implement get_application_by_id(application_id) -> Application
  - [ ] Implement get_application_by_job_id(job_id) -> Application
  - [ ] Implement update_application_status(application_id, status)
  - [ ] Implement update_application_stage(application_id, stage, outputs)
  - [ ] Implement list_applications(filters, limit, offset) -> List[Application]
  - [ ] Add completed_stages management functions
  - [ ] Add error_info management functions

- [ ] Create domain models (AC: 6)
  - [ ] Create app/models/__init__.py
  - [ ] Create app/models/job.py with Job dataclass/Pydantic model
  - [ ] Create app/models/application.py with Application model
  - [ ] Add validation for ENUM fields
  - [ ] Add JSON field serialization/deserialization
  - [ ] Add created_at/updated_at auto-population

- [ ] Write unit tests for database operations
  - [ ] Create tests/unit/repositories/__init__.py
  - [ ] Create tests/unit/repositories/test_database.py
  - [ ] Test connection creation and singleton pattern
  - [ ] Test database initialization
  - [ ] Test table creation
  - [ ] Test index creation
  - [ ] Use in-memory DuckDB for testing (:memory:)

- [ ] Write unit tests for jobs repository
  - [ ] Create tests/unit/repositories/test_jobs_repository.py
  - [ ] Test insert_job creates record with UUID
  - [ ] Test get_job_by_id retrieves correct record
  - [ ] Test get_job_by_url retrieves correct record
  - [ ] Test get_job_by_url returns None for non-existent URL
  - [ ] Test update_job modifies fields correctly
  - [ ] Test delete_job removes record
  - [ ] Test list_jobs with filters
  - [ ] Test list_jobs pagination
  - [ ] Test unique constraint on job_url
  - [ ] Test foreign key integrity

- [ ] Write unit tests for application repository
  - [ ] Create tests/unit/repositories/test_application_repository.py
  - [ ] Test insert_application creates record
  - [ ] Test get_application_by_id retrieves record
  - [ ] Test get_application_by_job_id retrieves correct record
  - [ ] Test update_application_status changes status
  - [ ] Test update_application_stage updates stage data
  - [ ] Test completed_stages array management
  - [ ] Test stage_outputs JSON storage
  - [ ] Test error_info JSON storage
  - [ ] Test cascade delete (when job deleted)

- [ ] Write integration tests
  - [ ] Create tests/integration/repositories/__init__.py
  - [ ] Create tests/integration/repositories/test_database_integration.py
  - [ ] Test full workflow: init DB → insert job → create application → update status
  - [ ] Test concurrent access from multiple threads
  - [ ] Test database file creation in data/ directory
  - [ ] Test index performance on queries
  - [ ] Test JSON column queries
  - [ ] Measure query performance benchmarks

- [ ] Update FastAPI integration
  - [ ] Update app/main.py to initialize database on startup
  - [ ] Add database health check to /health endpoint
  - [ ] Create /api/jobs endpoints (list, get)
  - [ ] Create /api/applications endpoints (list, get)
  - [ ] Add database info to /api/config endpoint

- [ ] Write documentation
  - [ ] Document database schema in README.md
  - [ ] Document CRUD API usage
  - [ ] Add ER diagram for tables
  - [ ] Document JSON column structures
  - [ ] Add query examples
  - [ ] Document migration process (if implemented)

## Dev Notes

### Database Schema Details
[Source: prd/epic-1-foundation.md#story-1-3]

```sql
-- jobs table
CREATE TABLE jobs (
    job_id UUID PRIMARY KEY,
    platform_source VARCHAR CHECK(platform_source IN ('linkedin', 'seek', 'indeed')),
    company_name VARCHAR NOT NULL,
    job_title VARCHAR NOT NULL,
    job_url VARCHAR NOT NULL UNIQUE,
    salary_aud_per_day DECIMAL(10,2),
    location VARCHAR,
    posted_date DATE,
    job_description TEXT,
    requirements TEXT,
    responsibilities TEXT,
    discovered_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    duplicate_group_id UUID
);

-- application_tracking table
CREATE TABLE application_tracking (
    application_id UUID PRIMARY KEY,
    job_id UUID NOT NULL,
    status VARCHAR CHECK(status IN (
        'discovered', 'matched', 'documents_generated', 'ready_to_send',
        'sending', 'completed', 'pending', 'failed', 'rejected', 'duplicate'
    )),
    current_stage VARCHAR,
    completed_stages JSON,
    stage_outputs JSON,
    error_info JSON,
    cv_file_path VARCHAR,
    cl_file_path VARCHAR,
    submission_method VARCHAR CHECK(submission_method IN ('email', 'web_form')),
    submitted_timestamp TIMESTAMP,
    contact_person_name VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (job_id) REFERENCES jobs(job_id) ON DELETE CASCADE
);

-- Indexes
CREATE UNIQUE INDEX idx_jobs_url ON jobs(job_url);
CREATE INDEX idx_jobs_platform_date ON jobs(platform_source, posted_date);
CREATE INDEX idx_app_status ON application_tracking(status);
CREATE INDEX idx_app_job_id ON application_tracking(job_id);
```

### DuckDB Connection Pattern
[Source: architecture/12-technology-stack.md#duckdb]

```python
import duckdb
from pathlib import Path
from threading import Lock

class DatabaseConnection:
    """Thread-safe DuckDB connection singleton."""
    _instance = None
    _lock = Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        db_path = Path("data/jobs.duckdb")
        db_path.parent.mkdir(exist_ok=True)
        self.conn = duckdb.connect(str(db_path))
        self.conn.execute("PRAGMA enable_object_cache")

    def get_connection(self):
        return self.conn
```

### Repository Pattern
[Source: architecture/13-implementation-patterns.md#repository-pattern]

```python
from typing import Optional, List
from uuid import UUID
from app.models.job import Job

class JobsRepository:
    """Repository for job CRUD operations."""

    def __init__(self, db_connection):
        self.db = db_connection

    def insert_job(self, job: Job) -> UUID:
        """Insert new job into database."""
        query = """
            INSERT INTO jobs (
                job_id, platform_source, company_name, job_title,
                job_url, salary_aud_per_day, location, posted_date,
                job_description, requirements, responsibilities
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """
        self.db.execute(query, [
            job.job_id, job.platform_source, job.company_name,
            job.job_title, job.job_url, job.salary_aud_per_day,
            job.location, job.posted_date, job.job_description,
            job.requirements, job.responsibilities
        ])
        return job.job_id

    def get_job_by_url(self, job_url: str) -> Optional[Job]:
        """Retrieve job by URL (for duplicate detection)."""
        result = self.db.execute(
            "SELECT * FROM jobs WHERE job_url = ?", [job_url]
        ).fetchone()
        return Job.from_db_row(result) if result else None
```

### JSON Column Structure
[Source: prd/4-configuration-data.md#agent-outputs]

```python
# completed_stages example
completed_stages = [
    "job_matcher_agent",
    "salary_validator_agent",
    "cv_tailor_agent"
]

# stage_outputs example
stage_outputs = {
    "job_matcher_agent": {
        "match_score": 0.85,
        "match_reasons": ["Python required", "Azure experience"],
        "rejection_reasons": []
    },
    "cv_tailor_agent": {
        "cv_file_path": "export/JobTitle_Company_CV.docx",
        "modifications_made": ["Added Azure project", "Highlighted Python"]
    }
}

# error_info example
error_info = {
    "stage": "cover_letter_agent",
    "error_type": "APIError",
    "error_message": "Claude API timeout",
    "timestamp": "2025-01-15T10:30:00Z"
}
```

### Testing Strategy
[Source: architecture/12-technology-stack.md#testing]

- **Unit Tests**: Use in-memory DuckDB (`:memory:`) for fast tests
- **Integration Tests**: Use temporary database files
- **Thread Safety**: Test concurrent inserts/updates
- **Performance**: Benchmark queries with indexes
- **Coverage Target**: 90%+ for repository modules

### Migration Strategy (Optional)
[Source: architecture/9-deployment-architecture.md#migrations]

If implementing migrations:
```python
# migrations/001_initial_schema.py
def up(conn):
    conn.execute("CREATE TABLE jobs (...)")
    conn.execute("CREATE TABLE application_tracking (...)")
    conn.execute("CREATE INDEX idx_jobs_url ON jobs(job_url)")

def down(conn):
    conn.execute("DROP TABLE application_tracking")
    conn.execute("DROP TABLE jobs")
```

## Testing

### Testing Standards
[Source: architecture/12-technology-stack.md#development-tools]

- **Test Framework:** pytest 7.4+
- **Database Testing:** In-memory DuckDB for unit tests
- **Coverage Target:** 90%+ for app/repositories/
- **Fixtures:** pytest fixtures for database setup/teardown

### Test Cases for Story 1.3
**Database Connection:**
- Test singleton pattern returns same connection
- Test connection to data/jobs.duckdb
- Test thread-safe access

**Schema Creation:**
- Test jobs table created with correct columns
- Test application_tracking table created with correct columns
- Test indexes created successfully
- Test foreign key constraints
- Test ENUM constraints

**Jobs Repository:**
- Test insert_job with valid data
- Test insert_job with duplicate URL fails
- Test get_job_by_id returns correct job
- Test get_job_by_url returns correct job
- Test update_job modifies fields
- Test delete_job removes record
- Test list_jobs with filters and pagination

**Application Repository:**
- Test insert_application with valid data
- Test foreign key constraint (job_id must exist)
- Test update_application_status
- Test update_application_stage with JSON outputs
- Test completed_stages array operations
- Test error_info JSON storage
- Test cascade delete when job deleted

**Integration Tests:**
- Test full workflow: insert job → create application → update status
- Test concurrent access from multiple threads
- Test index performance on large dataset
- Test JSON column queries (e.g., filter by status in stage_outputs)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-28 | 1.0 | Initial story draft created | SM Agent (Bob) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Implementation Notes
- Followed TDD methodology: RED (write tests) → GREEN (implement code) → REFACTOR
- Created in-memory database support for fast unit testing (`:memory:`)
- Implemented singleton pattern for database connection management
- Used dataclasses for domain models (Job, Application)
- JSON columns for flexible agent pipeline data storage
- Cascade delete ensures data integrity (job deletion → application deletion)
- Comprehensive error handling with loguru logging
- Type hints throughout for better IDE support and validation

### Files Created
**Domain Models:**
- app/models/job.py (Job dataclass with to_dict/from_db_row methods)
- app/models/application.py (Application dataclass with JSON serialization)
- app/models/__init__.py (exports)

**Database Layer:**
- app/repositories/database.py (enhanced with create_tables, create_indexes, get_connection)
- app/repositories/jobs_repository.py (full CRUD for jobs)
- app/repositories/application_repository.py (full CRUD for applications)
- app/repositories/__init__.py (updated exports)

**Scripts:**
- scripts/init_db.py (CLI script for database initialization with --reset flag)

**Unit Tests:**
- tests/unit/repositories/conftest.py (test fixtures with TESTING env var)
- tests/unit/repositories/test_database.py (12 tests for database operations)
- tests/unit/repositories/test_jobs_repository.py (21 tests for jobs CRUD)
- tests/unit/repositories/test_application_repository.py (18 tests for application CRUD)
- tests/unit/repositories/__init__.py

**Integration Tests:**
- tests/integration/repositories/test_database_integration.py (9 comprehensive integration tests)
- tests/integration/repositories/__init__.py

**API Updates:**
- app/main.py (added 4 new endpoints: GET /api/jobs, GET /api/jobs/{id}, GET /api/applications, GET /api/applications/{id})
- Updated /health endpoint with table count
- Updated /api/config endpoint with database info

### Test Coverage
- Unit tests: 51 tests covering database, jobs, and application operations
- Integration tests: 9 tests covering full workflows
- All tests use in-memory database for speed
- Tests cover: CRUD operations, foreign key constraints, unique constraints, cascade deletes, JSON storage, pagination, filtering

### Implementation Highlights
1. **Thread-safe Database Connection**: Singleton pattern ensures single connection per process
2. **Domain Models**: Clean separation between database and business logic
3. **Repository Pattern**: Encapsulates all database operations
4. **Type Safety**: Full type hints enable better IDE support
5. **JSON Storage**: Flexible agent output storage in stage_outputs and error_info
6. **Indexes**: Performance optimization with unique and composite indexes
7. **FastAPI Integration**: RESTful endpoints with pagination support
8. **CLI Tool**: scripts/init_db.py for easy database setup

## QA Results
*To be filled by QA Agent after review*

## Architecture Review
*To be filled by Architect after review*

## Story Retrospective
*To be filled by SM Agent after merge*
