# Story 2.1: Agent Base Class and Infrastructure

## Status
Planned

**Started:** 2025-10-28
**Branch:** feature/story-2-1-agent-base-class

## Story
**As a** developer,
**I want to** create a base agent class with common functionality,
**so that** individual agents are consistent and easier to implement.

## Context
This is the first story in Epic 2 (Core Agents). It establishes the foundational infrastructure that all 7 specialized agents will inherit from. The base agent class provides common functionality including:
- Claude API integration
- Configuration loading from agents.yaml
- Database interaction for tracking agent execution
- Error handling and logging
- Result data structures

This foundation enables the other 7 agents (Stories 2.2-2.8) to focus on their specific business logic rather than boilerplate concerns.

## Dependencies
- ✅ Story 1.2: Configuration System (agents.yaml exists)
- ✅ Story 1.3: DuckDB Schema (application_tracking table exists)
- ✅ Epic 1 Complete: Foundation infrastructure operational

## Acceptance Criteria

### AC 1: BaseAgent Abstract Class
- [ ] `BaseAgent` abstract class created in `app/agents/base_agent.py`
- [ ] Abstract method: `async def process(self, job_id: str) -> AgentResult`
- [ ] Property: `agent_name` (returns agent's name)
- [ ] Property: `model` (returns Claude model to use)
- [ ] Method: `_load_config(agent_name: str)` loads from agents.yaml
- [ ] Method: `_call_claude(prompt: str, system: str, model: str) -> str` wraps Claude API
- [ ] Method: `_update_database(application_id: str, updates: dict)` updates application_tracking
- [ ] Logging integrated with loguru
- [ ] Execution time tracking (start, end, duration)
- [ ] Exception handling with proper error propagation

### AC 2: AgentResult Data Class
- [ ] `AgentResult` data class created in `app/agents/base_agent.py`
- [ ] Field: `success: bool` (whether agent succeeded)
- [ ] Field: `agent_name: str` (name of agent that produced result)
- [ ] Field: `output: dict[str, Any]` (agent-specific output data)
- [ ] Field: `error_message: str | None` (error details if failed)
- [ ] Field: `execution_time_ms: int` (time taken in milliseconds)
- [ ] Method: `to_dict() -> dict` for serialization
- [ ] Method: `@classmethod from_dict(cls, data: dict) -> AgentResult` for deserialization

### AC 3: Agent Registry System
- [ ] `AgentRegistry` class created in `app/agents/registry.py`
- [ ] Method: `register(agent_name: str, agent_class: Type[BaseAgent])` registers agent
- [ ] Method: `get_agent(agent_name: str) -> BaseAgent` retrieves agent instance
- [ ] Method: `get_next_agent(current_agent: str) -> BaseAgent | None` returns next in pipeline
- [ ] Method: `get_pipeline_order() -> list[str]` returns agent execution order
- [ ] Pipeline order defined: JobMatcher → SalaryValidator → CVTailor → CoverLetterWriter → QA → Orchestrator → FormHandler
- [ ] Singleton pattern (one registry instance)
- [ ] Thread-safe registration and retrieval
- [ ] Validation: agents must inherit from BaseAgent

### AC 4: Database Update Methods
- [ ] BaseAgent has access to `ApplicationRepository` via dependency injection
- [ ] Method: `_update_current_stage(application_id: str, stage: str)` updates current_stage
- [ ] Method: `_add_completed_stage(application_id: str, stage: str, output: dict)` appends to completed_stages
- [ ] Method: `_store_stage_output(application_id: str, agent_name: str, output: dict)` stores in stage_outputs
- [ ] Method: `_update_error_info(application_id: str, error: dict)` records error details
- [ ] Method: `_update_status(application_id: str, status: str)` updates application status
- [ ] All database updates wrapped in try-except with proper error logging
- [ ] Database operations tested with mocked repository

### AC 5: Unit Tests for Base Agent Functionality
- [ ] Test file: `tests/unit/agents/test_base_agent.py`
- [ ] Test: `test_base_agent_is_abstract()` verifies cannot instantiate BaseAgent directly
- [ ] Test: `test_agent_result_creation()` validates AgentResult fields
- [ ] Test: `test_agent_result_serialization()` tests to_dict/from_dict
- [ ] Test: `test_config_loading()` mocks yaml loading and verifies config
- [ ] Test: `test_claude_api_call()` mocks Claude API and verifies request
- [ ] Test: `test_execution_time_tracking()` verifies timing captured
- [ ] Test: `test_database_update_methods()` mocks database and verifies updates
- [ ] Test: `test_error_handling()` verifies exceptions handled properly
- [ ] Test: `test_agent_registry_registration()` tests agent registration
- [ ] Test: `test_agent_registry_retrieval()` tests agent retrieval
- [ ] Test: `test_agent_registry_pipeline_order()` validates pipeline sequence
- [ ] Test: `test_agent_registry_singleton()` ensures only one instance
- [ ] Minimum 90% code coverage for base_agent.py and registry.py

## Implementation Plan

### Phase 1: Data Structures
**Files:** `app/agents/__init__.py`, `app/agents/base_agent.py`

1. Create `app/agents/` package directory
2. Define `AgentResult` dataclass with all fields
3. Add serialization methods (to_dict, from_dict)
4. Add unit tests for AgentResult

### Phase 2: Base Agent Abstract Class
**Files:** `app/agents/base_agent.py`

1. Define `BaseAgent` as ABC (Abstract Base Class)
2. Add abstract `process(job_id: str) -> AgentResult` method
3. Add constructor accepting:
   - `config: dict` (agent-specific config from agents.yaml)
   - `claude_client: AnthropicClient` (Claude API client)
   - `app_repository: ApplicationRepository` (database access)
4. Implement `_load_config(agent_name: str)` method:
   - Load from `config/agents.yaml`
   - Cache configuration
   - Validate required fields present
5. Implement `_call_claude(prompt: str, system: str, model: str)` method:
   - Wrap Anthropic Claude API
   - Handle API errors (rate limits, network errors)
   - Log request/response
   - Track token usage
6. Add properties: `agent_name`, `model`
7. Add execution time tracking:
   - Record start_time before processing
   - Record end_time after processing
   - Calculate duration_ms
8. Add structured logging with loguru:
   - Log agent start
   - Log agent completion
   - Log errors with full context

### Phase 3: Database Update Methods
**Files:** `app/agents/base_agent.py`

1. Inject `ApplicationRepository` into BaseAgent constructor
2. Implement `_update_current_stage(application_id, stage)`
3. Implement `_add_completed_stage(application_id, stage, output)`
4. Implement `_store_stage_output(application_id, agent_name, output)`
5. Implement `_update_error_info(application_id, error)`
6. Implement `_update_status(application_id, status)`
7. Wrap all database calls in try-except
8. Log database updates

### Phase 4: Agent Registry
**Files:** `app/agents/registry.py`

1. Create `AgentRegistry` class with singleton pattern
2. Add `_agents: dict[str, Type[BaseAgent]]` storage
3. Add `_pipeline_order: list[str]` defining agent sequence:
   - "job_matcher"
   - "salary_validator"
   - "cv_tailor"
   - "cover_letter_writer"
   - "qa"
   - "orchestrator"
   - "form_handler"
4. Implement `register(agent_name, agent_class)`:
   - Validate agent_class inherits from BaseAgent
   - Store in _agents dict
   - Log registration
5. Implement `get_agent(agent_name) -> BaseAgent`:
   - Retrieve from _agents dict
   - Instantiate with dependencies
   - Return instance
6. Implement `get_next_agent(current_agent) -> BaseAgent | None`:
   - Find current agent in pipeline_order
   - Return next agent or None if last
7. Implement `get_pipeline_order() -> list[str]`:
   - Return copy of _pipeline_order
8. Add thread safety with threading.Lock

### Phase 5: Unit Testing
**Files:** `tests/unit/agents/test_base_agent.py`, `tests/unit/agents/test_registry.py`

1. Create test fixtures:
   - Mock config data
   - Mock Claude API responses
   - Mock ApplicationRepository
   - Concrete test agent class (inherits BaseAgent)
2. Write tests for AgentResult (serialization, validation)
3. Write tests for BaseAgent:
   - Cannot instantiate abstract class
   - Config loading
   - Claude API calls
   - Database updates
   - Error handling
   - Execution time tracking
4. Write tests for AgentRegistry:
   - Registration
   - Retrieval
   - Pipeline order
   - Singleton pattern
   - Thread safety
5. Achieve ≥90% code coverage
6. All tests must pass

### Phase 6: Integration Point Preparation
**Files:** `app/services/job_processor.py` (stub update)

1. Update JobProcessorService stub to use BaseAgent:
   ```python
   async def process_job(self, job_id: str) -> dict:
       """Process job through agent pipeline"""
       registry = AgentRegistry.get_instance()
       results = {}

       for agent_name in registry.get_pipeline_order():
           agent = registry.get_agent(agent_name)
           result = await agent.process(job_id)
           results[agent_name] = result

           if not result.success:
               # Stop pipeline on failure
               break

       return results
   ```
2. Add basic integration test (mock agents)
3. Verify pipeline orchestration works

## File Structure
```
app/
  agents/
    __init__.py              # Package exports (BaseAgent, AgentResult, AgentRegistry)
    base_agent.py            # BaseAgent abstract class, AgentResult dataclass
    registry.py              # AgentRegistry singleton
tests/
  unit/
    agents/
      __init__.py
      test_base_agent.py     # Unit tests for BaseAgent and AgentResult
      test_registry.py       # Unit tests for AgentRegistry
  integration/
    agents/
      __init__.py
      test_agent_pipeline.py # Integration test for agent orchestration
```

## Technical Design

### BaseAgent Class Structure
```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Any, Optional
import time
from loguru import logger

@dataclass
class AgentResult:
    """Result from an agent execution"""
    success: bool
    agent_name: str
    output: dict[str, Any]
    error_message: Optional[str] = None
    execution_time_ms: int = 0

    def to_dict(self) -> dict:
        """Serialize to dictionary"""
        return {
            "success": self.success,
            "agent_name": self.agent_name,
            "output": self.output,
            "error_message": self.error_message,
            "execution_time_ms": self.execution_time_ms,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "AgentResult":
        """Deserialize from dictionary"""
        return cls(**data)

class BaseAgent(ABC):
    """
    Abstract base class for all agents in the pipeline.

    Provides common functionality:
    - Claude API integration
    - Configuration loading
    - Database tracking
    - Error handling and logging
    """

    def __init__(
        self,
        config: dict,
        claude_client: Any,  # AnthropicClient
        app_repository: Any,  # ApplicationRepository
    ):
        self._config = config
        self._claude = claude_client
        self._app_repo = app_repository
        self._start_time = None
        self._end_time = None

    @property
    @abstractmethod
    def agent_name(self) -> str:
        """Return agent's name"""
        pass

    @property
    def model(self) -> str:
        """Return Claude model to use"""
        return self._config.get("model", "claude-sonnet-4")

    @abstractmethod
    async def process(self, job_id: str) -> AgentResult:
        """
        Process a job through this agent.

        Args:
            job_id: ID of job to process

        Returns:
            AgentResult with success status and output
        """
        pass

    async def _call_claude(
        self,
        prompt: str,
        system: str,
        model: Optional[str] = None,
    ) -> str:
        """Call Claude API with error handling"""
        model = model or self.model
        try:
            response = await self._claude.messages.create(
                model=model,
                system=system,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=4096,
            )
            return response.content[0].text
        except Exception as e:
            logger.error(f"Claude API error in {self.agent_name}: {e}")
            raise

    async def _update_current_stage(self, application_id: str, stage: str):
        """Update current processing stage in database"""
        # Implementation with error handling
        pass

    # ... other database methods ...
```

### Agent Registry Structure
```python
from typing import Type, Optional
import threading

class AgentRegistry:
    """
    Singleton registry for all agents in the system.
    Manages agent registration and pipeline execution order.
    """

    _instance = None
    _lock = threading.Lock()

    def __init__(self):
        self._agents: dict[str, Type[BaseAgent]] = {}
        self._pipeline_order = [
            "job_matcher",
            "salary_validator",
            "cv_tailor",
            "cover_letter_writer",
            "qa",
            "orchestrator",
            "form_handler",
        ]

    @classmethod
    def get_instance(cls) -> "AgentRegistry":
        """Get singleton instance (thread-safe)"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = cls()
        return cls._instance

    def register(self, agent_name: str, agent_class: Type[BaseAgent]):
        """Register an agent class"""
        if not issubclass(agent_class, BaseAgent):
            raise ValueError(f"{agent_class} must inherit from BaseAgent")
        self._agents[agent_name] = agent_class
        logger.info(f"Registered agent: {agent_name}")

    def get_agent(self, agent_name: str) -> BaseAgent:
        """Get agent instance by name"""
        # Implementation with dependency injection
        pass

    def get_next_agent(self, current_agent: str) -> Optional[BaseAgent]:
        """Get next agent in pipeline"""
        try:
            idx = self._pipeline_order.index(current_agent)
            if idx < len(self._pipeline_order) - 1:
                next_name = self._pipeline_order[idx + 1]
                return self.get_agent(next_name)
        except ValueError:
            logger.error(f"Agent {current_agent} not in pipeline")
        return None

    def get_pipeline_order(self) -> list[str]:
        """Get agent execution order"""
        return self._pipeline_order.copy()
```

## Integration with Existing Code

### Config Loading (Story 1.2)
- BaseAgent loads config from `config/agents.yaml` via ConfigLoader
- Each agent has its own config section (job_matcher_agent, cv_tailor_agent, etc.)
- Config includes: model, thresholds, paths, etc.

### Database Updates (Story 1.3)
- BaseAgent uses ApplicationRepository from Story 1.3
- Updates application_tracking table fields:
  - current_stage (current agent name)
  - completed_stages (list of completed agents)
  - stage_outputs (dict of agent outputs)
  - error_info (error details if agent fails)
  - status (overall application status)

### Claude API Integration
- Use Anthropic Python SDK
- API key from environment variable (ANTHROPIC_API_KEY)
- Model selection per agent from config
- Error handling for rate limits, network errors

## Testing Strategy

### Unit Tests
1. **AgentResult Tests:**
   - Test field validation
   - Test serialization/deserialization
   - Test with various data types

2. **BaseAgent Tests:**
   - Mock all dependencies (config, claude, database)
   - Test abstract nature (cannot instantiate)
   - Test config loading
   - Test Claude API calls
   - Test database update methods
   - Test error propagation
   - Test execution time tracking

3. **AgentRegistry Tests:**
   - Test registration with valid/invalid agents
   - Test retrieval
   - Test pipeline order
   - Test singleton pattern
   - Test thread safety with concurrent access

### Integration Tests
1. **Agent Pipeline Test:**
   - Create mock agents implementing BaseAgent
   - Register in registry
   - Execute pipeline with JobProcessorService
   - Verify execution order
   - Verify result aggregation

### Coverage Target
- Minimum 90% code coverage for:
  - `app/agents/base_agent.py`
  - `app/agents/registry.py`

## QA Test Plan

### Manual Testing Scenarios

**Scenario 1: Base Agent Creation**
1. Attempt to instantiate BaseAgent directly
2. Expect: TypeError (abstract class)
3. Create concrete test agent inheriting BaseAgent
4. Expect: Successful instantiation

**Scenario 2: Agent Registry**
1. Get AgentRegistry instance
2. Register test agent
3. Retrieve agent by name
4. Expect: Agent instance returned
5. Get pipeline order
6. Expect: Correct sequence returned

**Scenario 3: AgentResult Serialization**
1. Create AgentResult with test data
2. Serialize to dict
3. Deserialize back to AgentResult
4. Expect: Data preserved correctly

**Scenario 4: Config Loading**
1. Mock agents.yaml with test config
2. Create agent with config loading
3. Expect: Config loaded correctly
4. Access config values
5. Expect: Correct values returned

**Scenario 5: Database Update Tracking**
1. Mock ApplicationRepository
2. Create test agent
3. Call database update methods
4. Expect: Repository methods called with correct parameters
5. Verify: completed_stages updated
6. Verify: stage_outputs stored

### Acceptance Criteria Validation

For each AC (1-5), QA will:
- Review code implementation
- Run unit tests and verify pass
- Check code coverage meets 90%
- Verify integration points work
- Test error scenarios
- Document any issues found

## Architecture Review Checklist

- [ ] BaseAgent follows SOLID principles (especially Interface Segregation)
- [ ] Dependency injection used for testability
- [ ] Abstract methods clearly defined
- [ ] AgentResult is immutable data structure
- [ ] AgentRegistry uses singleton pattern correctly
- [ ] Thread-safe agent registration
- [ ] Clean separation: BaseAgent (behavior) vs AgentResult (data)
- [ ] Error handling comprehensive
- [ ] Logging structured and informative
- [ ] Integration with Story 1.2 (config) and 1.3 (database) clean
- [ ] Foundation scalable for 7 agent implementations
- [ ] Type hints throughout
- [ ] Docstrings on all public methods
- [ ] No hardcoded values (use config)

## Success Metrics

- [ ] All 5 acceptance criteria met
- [ ] ≥90% test coverage achieved
- [ ] All unit tests passing (100% pass rate)
- [ ] Integration test demonstrates pipeline works
- [ ] Code review approved (no critical issues)
- [ ] QA validation complete (all scenarios pass)
- [ ] Architecture review approved
- [ ] Zero bugs found in testing
- [ ] Documentation complete (this file + docstrings)
- [ ] PR created and ready for merge

## Risks and Mitigations

### Risk 1: Claude API Integration Complexity
**Mitigation:**
- Use Anthropic SDK (well-documented)
- Mock Claude responses in tests
- Add retry logic for transient failures

### Risk 2: Thread Safety in AgentRegistry
**Mitigation:**
- Use threading.Lock for singleton creation
- Immutable pipeline order
- Thread-safe dict operations

### Risk 3: Database Update Failures
**Mitigation:**
- Wrap all DB calls in try-except
- Log all errors with context
- Don't block agent execution on DB failures
- Add retry logic for DB operations

### Risk 4: Abstract Class Complexity
**Mitigation:**
- Clear documentation with examples
- Provide concrete test agent as reference
- Use ABC from Python standard library (well-tested)

## Notes for Implementation

- This story creates the foundation for all agent implementations (Stories 2.2-2.8)
- Focus on clean abstractions and testability
- Keep BaseAgent lean - only common functionality
- Agent-specific logic belongs in concrete agent classes
- Use dependency injection for all external dependencies
- Mock all external dependencies in unit tests
- Integration test should use mock agents, not real Claude API

## Story Dependencies Flow

```
Story 1.2 (Config) ──┐
                     ├──> Story 2.1 (Base Agent) ──> Story 2.2 (Job Matcher)
Story 1.3 (Database)─┘                           ├──> Story 2.3 (Salary Validator)
                                                  ├──> Story 2.4 (CV Tailor)
                                                  ├──> Story 2.5 (Cover Letter)
                                                  ├──> Story 2.6 (QA Agent)
                                                  ├──> Story 2.7 (Orchestrator)
                                                  └──> Story 2.8 (Checkpoint System)
```

## Ready for Development

All prerequisites met:
- ✅ Epic 1 foundation complete
- ✅ Configuration system operational
- ✅ Database schema established
- ✅ Requirements clearly defined
- ✅ Architecture patterns identified
- ✅ Test strategy documented

**Feature Branch:** feature/story-2-1-agent-base-class
**Next Step:** TDD Implementation (Dev Agent)
