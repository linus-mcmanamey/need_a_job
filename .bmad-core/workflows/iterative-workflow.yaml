# <!-- Powered by BMAD‚Ñ¢ Core -->
# Job Application Automation System - Iterative Story Development
# Project: need_a_job
# Tech Stack: Python 3.11+, FastAPI, Redis+RQ, DuckDB, Gradio, Claude LLM
#
# ========================================================================
# FULLY AUTONOMOUS WORKFLOW - ORCHESTRATOR CONTROLLED
# ========================================================================
# This workflow is controlled entirely by the bmad-orchestrator.
# Agents complete their tasks and IMMEDIATELY hand back control to orchestrator.
# Orchestrator validates completion and IMMEDIATELY activates next step.
# NO USER INTERACTION AT ANY POINT - Complete autonomous execution.
#
# ORCHESTRATOR CONTROL MODEL:
#   1. Orchestrator activates agent for specific step
#   2. Agent completes task autonomously
#   3. Agent hands back control to orchestrator WITH completion status
#   4. Orchestrator validates completion criteria
#   5. Orchestrator IMMEDIATELY proceeds to next step (no pause, no user prompt)
#   6. Loop continues until all 28 stories complete
#
# HANDBACK PROTOCOL:
#   Every step includes "handback_to_orchestrator: true"
#   Orchestrator receives: {step_complete: bool, next_step: string, context: dict}
#   Orchestrator validates quality gates
#   Orchestrator activates next step WITHOUT user confirmation
#
# ZERO USER INTERACTION POINTS:
#   - Story selection ‚Üí Planning (auto)
#   - Planning ‚Üí Implementation (auto)
#   - Implementation ‚Üí Code Review (auto)
#   - Code Review ‚Üí QA (auto)
#   - QA ‚Üí Architect Review (auto)
#   - Architect ‚Üí SM Approval (auto)
#   - SM Approval ‚Üí PR Creation (auto)
#   - PR Creation ‚Üí PR Review (auto)
#   - PR Review ‚Üí Merge (auto)
#   - Merge ‚Üí Retrospective (auto)
#   - Retrospective ‚Üí Next Story (auto) ‚Üê CRITICAL: NO USER PROMPT HERE
#   - Epic Complete ‚Üí Next Epic (auto) ‚Üê CRITICAL: NO USER PROMPT HERE
#
# CONTINUOUS EXECUTION: Workflow runs 1.1 ‚Üí 1.2 ‚Üí ... ‚Üí 6.4 without stopping
# ========================================================================

workflow:
  id: iterative-story-development
  name: Job Application Automation - Iterative Story Development
  description: >-
    FULLY AUTONOMOUS orchestrator-controlled workflow for iterative development.
    The bmad-orchestrator maintains control throughout all 28 stories across 6 epics.
    Agents complete tasks and IMMEDIATELY hand back control to orchestrator.
    Orchestrator validates and IMMEDIATELY proceeds to next step.
    ZERO USER INTERACTION REQUIRED AT ANY POINT.
  type: iterative
  automation_mode: fully_autonomous_orchestrator_controlled
  orchestration_control: bmad-orchestrator
  execution_policy: continuous_until_project_complete
  handback_protocol: agents_return_control_immediately
  user_interaction: absolutely_none

  project_types:
    - python-development
    - fastapi-backend
    - llm-integration
    - agile-development
    - story-driven-development
    - multi-agent-system

  orchestration_model:
    controller: bmad-orchestrator
    control_mechanism: explicit_handback_per_step
    validation_mode: orchestrator_validates_each_step
    progression_policy: immediate_next_step_on_validation
    user_approval_required: never

    orchestrator_responsibilities: |
      The bmad-orchestrator is the ONLY entity that controls workflow progression:

      1. STEP ACTIVATION:
         - Orchestrator selects next step based on workflow sequence
         - Orchestrator activates appropriate agent for that step
         - Orchestrator provides agent with: story context, previous outputs, quality criteria

      2. AGENT MONITORING:
         - Agent executes its specific task autonomously
         - Orchestrator monitors for completion signal
         - Agent MUST signal completion with handback_to_orchestrator

      3. VALIDATION & PROGRESSION:
         - Orchestrator receives completion signal from agent
         - Orchestrator validates quality gates for that step
         - Orchestrator IMMEDIATELY activates next step (no user prompt, no pause)
         - If validation fails ‚Üí Orchestrator activates retry/fix step
         - If validation passes ‚Üí Orchestrator proceeds to next step

      4. STATE MANAGEMENT:
         - Orchestrator maintains: current_epic, current_story, current_step
         - Orchestrator tracks: completed_stories, quality_metrics, blockers
         - Orchestrator makes ALL decisions about: retries, next steps, epic transitions

      5. AUTONOMOUS DECISIONS (Never ask user):
         - Next story selection ‚Üí Orchestrator decides based on sequence
         - Epic transition ‚Üí Orchestrator proceeds automatically
         - Retry after failure ‚Üí Orchestrator triggers retry loop
         - Project completion ‚Üí Orchestrator validates and concludes

      CRITICAL RULE: Orchestrator NEVER asks user "Should I continue?" or presents options.
      Orchestrator ALWAYS informs user "Proceeding to X" and continues immediately.

    handback_mechanism: |
      Every workflow step follows this pattern:

      STEP EXECUTION:
        1. Orchestrator ‚Üí Agent: "Execute step X with context Y"
        2. Agent: Performs task autonomously
        3. Agent ‚Üí Orchestrator: "Step complete. Status: SUCCESS/FAILED. Output: {...}"
        4. Orchestrator: Validates output against quality gates
        5. Orchestrator: If PASS ‚Üí Activate next step. If FAIL ‚Üí Activate fix step.

      HANDBACK FORMAT:
        {
          step_id: "string",
          step_status: "completed" | "failed" | "blocked",
          quality_gates_passed: boolean,
          next_step_recommended: "string",
          context_for_next_step: {...},
          blocking_issues: [...] or null
        }

      ORCHESTRATOR RESPONSE:
        - Validates handback against quality criteria
        - Updates workflow state
        - IMMEDIATELY activates next step (no delay, no user prompt)
        - Logs progression: "Step X complete. Proceeding to step Y."

  critical_orchestration_rules: |
    üö® ABSOLUTE RULES - NO EXCEPTIONS:

    1. AGENTS HAND BACK CONTROL IMMEDIATELY AFTER TASK COMPLETION
       ‚úÖ DO: Complete task ‚Üí Signal orchestrator ‚Üí Wait for next activation
       ‚ùå NEVER: Complete task ‚Üí Ask user what to do next
       ‚ùå NEVER: Complete task ‚Üí Assume next step and proceed without orchestrator

    2. ORCHESTRATOR VALIDATES AND PROGRESSES IMMEDIATELY
       ‚úÖ DO: Receive handback ‚Üí Validate ‚Üí Activate next step immediately
       ‚ùå NEVER: Receive handback ‚Üí Ask user for approval to continue
       ‚ùå NEVER: Receive handback ‚Üí Wait for user input before proceeding

    3. ZERO USER PROMPTS FOR CONTINUATION
       ‚ùå NEVER say: "Would you like me to continue to Story X?"
       ‚ùå NEVER say: "Should I proceed? A) Yes B) No C) Review"
       ‚ùå NEVER present options or ask for direction
       ‚úÖ ALWAYS say: "Story X complete. Proceeding to Story Y immediately."
       ‚úÖ ALWAYS inform of actions, never ask permission

    4. EPIC TRANSITIONS ARE AUTOMATIC
       When all stories in epic complete:
       ‚úÖ Orchestrator: Triggers epic_completion step
       ‚úÖ PM: Documents epic summary and hands back to orchestrator
       ‚úÖ Orchestrator: IMMEDIATELY proceeds to first story of next epic
       ‚ùå NEVER: Ask user "Epic X complete. Start Epic Y? Yes/No"

    5. STORY TRANSITIONS ARE IMMEDIATE
       After story retrospective:
       ‚úÖ SM: Documents retrospective and hands back to orchestrator
       ‚úÖ Orchestrator: IMMEDIATELY proceeds to story_selection for next story
       ‚ùå NEVER: Pause and wait for user to say "continue"
       ‚ùå NEVER: Ask "Ready for next story?"

    6. FAILURE HANDLING IS AUTONOMOUS
       When quality gate fails:
       ‚úÖ Orchestrator: Automatically activates fix step (dev_fixes, pr_changes, etc.)
       ‚úÖ Agent: Fixes issues and hands back to orchestrator
       ‚úÖ Orchestrator: Re-runs validation step
       ‚ùå NEVER: Ask user "Tests failed. What should I do?"

    7. WORKFLOW TERMINATION CONDITION
       The ONLY stopping point is: all_epics_complete (Epic 6, Story 6.4 merged)
       Until then, orchestrator CONTINUOUSLY loops through stories
       User observes progress but does NOT direct execution

  sequence:
    - step: prerequisites_check
      agent: sm
      action: verify prerequisites and environment
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - python_environment_ready
        - redis_server_accessible
        - duckdb_initialized
        - dependencies_installed
        - prd_files_present
      on_validation_pass: proceed_to_story_selection
      on_validation_fail: log_issues_and_attempt_remediation
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates SM to check prerequisites
        - SM checks: Python 3.11+, Redis, DuckDB, dependencies, PRD, configs
        - SM hands back: {step_status: "completed", prerequisites_met: boolean, issues: [...]}
        - Orchestrator validates: If all prerequisites met ‚Üí proceed to story_selection
        - Orchestrator: If issues found ‚Üí logs for user review, attempts auto-fix where possible
        - NO USER APPROVAL NEEDED - Orchestrator proceeds automatically

    - step: story_selection
      agent: sm
      action: select next story from PRD epics in sequential order
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - story_selected_matches_sequence
        - story_prerequisites_met
        - story_file_structure_correct
      on_validation_pass: proceed_to_story_planning
      next_step_automatic: story_planning
      reviews:
        - docs/prd/epic-*.md
        - docs/prd/7-implementation-roadmap.md
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates SM with instruction: "Select next story in sequence"
        - SM autonomously determines next story (Epic X, Story Y) based on:
          * Completed stories in docs/stories/
          * Epic sequence: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6
          * Story sequence within epic: X.1 ‚Üí X.2 ‚Üí X.3 ‚Üí ...
        - SM creates feature branch: feature/story-{epic}-{story}
        - SM hands back: {story_selected: "X.Y", story_title: "...", branch_created: "..."}
        - Orchestrator validates selection matches expected sequence
        - Orchestrator IMMEDIATELY proceeds to story_planning
        - NO USER CONFIRMATION REQUIRED

    - step: story_planning
      agent: sm
      action: create implementation plan from PRD acceptance criteria
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - story_document_created
        - acceptance_criteria_copied_from_prd
        - implementation_tasks_defined
        - test_strategy_documented
      on_validation_pass: proceed_to_conditional_analysis
      next_step_automatic: check_if_architecture_review_needed
      reviews:
        - docs/prd/epic-{epic}.md
        - docs/architecture/
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator provides SM with story details from PRD
        - SM creates detailed story document: docs/stories/{epic}.{story}.{title}.md
        - SM includes: acceptance criteria, implementation tasks, test strategy
        - SM hands back: {story_doc_created: true, complexity: "low|medium|high"}
        - Orchestrator validates story document completeness
        - Orchestrator checks complexity ‚Üí If high ‚Üí trigger architecture_review
        - Orchestrator IMMEDIATELY proceeds (no user input)

    - step: architecture_review
      agent: architect
      action: review technical design for architectural changes
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: architectural_changes_needed_or_high_complexity
      orchestrator_validates:
        - architecture_review_documented
        - design_patterns_approved
        - no_critical_architecture_issues
      on_validation_pass: proceed_to_story_implementation
      next_step_automatic: story_implementation
      notes: |
        ORCHESTRATOR CONTROL POINT (CONDITIONAL):
        - Orchestrator activates architect if: story complexity high OR architectural changes needed
        - Architect reviews: system design, database schema, API patterns, integration
        - Architect hands back: {approved: boolean, notes: "...", concerns: [...]}
        - Orchestrator validates: If approved ‚Üí proceed. If concerns ‚Üí return to SM for clarification
        - Orchestrator proceeds automatically based on validation

    - step: story_implementation
      agent: dev
      action: implement story using TDD (RED ‚Üí GREEN ‚Üí REFACTOR)
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - tdd_cycle_completed
        - all_unit_tests_passing
        - code_coverage_minimum_90_percent
        - code_quality_gates_passed
      on_validation_pass: proceed_to_code_review_security_scan
      next_step_automatic: code_review_security_scan
      branch: feature/story-{epic}-{story}
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates Dev with: story doc, PRD acceptance criteria, architecture notes
        - Dev implements using TDD: Write tests (RED) ‚Üí Implement (GREEN) ‚Üí Refactor
        - Dev runs: pytest, coverage report, ruff, black, mypy
        - Dev hands back: {
            implementation_complete: true,
            tests_passing: boolean,
            coverage_percentage: float,
            quality_checks_passed: boolean,
            files_changed: [...]
          }
        - Orchestrator validates: coverage ‚â• 90%, tests pass, quality gates pass
        - If validation fails ‚Üí Orchestrator returns to dev with specific issues
        - If validation passes ‚Üí Orchestrator IMMEDIATELY proceeds to code_review
        - NO USER APPROVAL REQUIRED

    - step: code_review_security_scan
      agent: code-reviewer
      action: security scan and code quality review before QA
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - no_critical_security_issues
        - no_exposed_secrets
        - code_quality_acceptable
        - review_documented
      on_validation_pass: proceed_to_qa_testing_cycle
      on_validation_fail: return_to_dev_with_issues
      next_step_automatic: qa_testing_cycle_or_dev_fixes
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates code-reviewer with: changed files, story context
        - Code-reviewer performs: security scan (secrets, injection), quality review
        - Code-reviewer hands back: {
            security_scan_passed: boolean,
            critical_issues: [...],
            warnings: [...],
            approved_for_qa: boolean
          }
        - Orchestrator validates: If critical issues found ‚Üí return to dev_fixes
        - Orchestrator: If approved ‚Üí IMMEDIATELY proceed to qa_testing_cycle
        - NO USER INPUT REQUIRED

    - step: qa_testing_cycle
      agent: qa
      action: verify all acceptance criteria with integration tests
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - all_acceptance_criteria_tested
        - all_tests_passed
        - integration_tests_successful
        - regression_tests_passed
      on_validation_pass: proceed_to_architect_final_review
      on_validation_fail: return_to_dev_fixes
      next_step_automatic: architect_final_review_or_dev_fixes
      iterates_until: all_criteria_pass
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates QA with: story doc, acceptance criteria, implementation
        - QA tests each acceptance criterion from PRD
        - QA performs: integration tests, regression tests, criterion validation
        - QA hands back: {
            all_criteria_passed: boolean,
            passing_criteria: [...],
            failing_criteria: [...],
            test_evidence: {...}
          }
        - Orchestrator validates test results
        - If failures ‚Üí Orchestrator activates dev_fixes step
        - If all pass ‚Üí Orchestrator IMMEDIATELY proceeds to architect_final_review
        - Loop continues until all tests pass (orchestrator manages retry logic)

    - step: dev_fixes
      agent: dev
      action: fix failing tests and address issues from QA or code-reviewer
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: qa_tests_failed_or_code_review_issues
      orchestrator_validates:
        - fixes_implemented
        - unit_tests_passing_locally
        - ready_for_retest
      on_validation_pass: return_to_qa_retest_or_code_review
      next_step_automatic: qa_retest_or_code_review
      notes: |
        ORCHESTRATOR CONTROL POINT (TRIGGERED BY FAILURE):
        - Orchestrator activates Dev when: QA finds failing tests OR code-reviewer finds issues
        - Orchestrator provides: specific failures/issues to fix
        - Dev fixes code, runs tests locally, verifies fixes
        - Dev hands back: {fixes_complete: true, issues_resolved: [...]}
        - Orchestrator validates fixes and automatically triggers retest
        - Orchestrator manages retry loop autonomously

    - step: qa_retest
      agent: qa
      action: retest fixes and verify resolution
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: after_dev_fixes
      orchestrator_validates:
        - previously_failing_tests_now_pass
        - no_new_regressions
        - all_criteria_still_met
      on_validation_pass: proceed_to_architect_final_review
      on_validation_fail: return_to_dev_fixes
      next_step_automatic: architect_final_review_or_dev_fixes_again
      notes: |
        ORCHESTRATOR CONTROL POINT (RETRY VALIDATION):
        - Orchestrator activates QA to retest after dev fixes
        - QA focuses on previously failing scenarios
        - QA hands back: {fixes_validated: boolean, new_issues: [...]}
        - If still failing ‚Üí Orchestrator returns to dev_fixes (loop continues)
        - If all pass ‚Üí Orchestrator proceeds to architect_final_review
        - Orchestrator manages this retry loop until success

    - step: architect_final_review
      agent: architect
      action: final implementation review for architecture compliance
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - architecture_compliance_verified
        - technical_debt_documented
        - no_critical_architecture_violations
      on_validation_pass: proceed_to_sm_story_approval
      next_step_automatic: sm_story_approval
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates Architect for final review
        - Architect reviews: implementation code, architecture patterns, technical debt
        - Architect hands back: {approved: boolean, technical_debt: [...], notes: "..."}
        - Orchestrator validates approval
        - Orchestrator IMMEDIATELY proceeds to sm_story_approval
        - NO USER CONFIRMATION

    - step: sm_story_approval
      agent: sm
      action: verify story completion and PRD alignment
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - all_acceptance_criteria_met
        - story_document_complete
        - ready_for_pr_creation
      on_validation_pass: proceed_to_create_pull_request
      next_step_automatic: create_pull_request
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates SM to verify story completion
        - SM checks: all ACs met, tests pass, coverage ‚â•90%, documentation complete
        - SM hands back: {story_complete: true, ready_for_pr: boolean}
        - Orchestrator validates story readiness
        - Orchestrator IMMEDIATELY proceeds to create_pull_request

    - step: create_pull_request
      agent: sm
      action: create PR for review and merge
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - pr_created_successfully
        - pr_description_complete
        - pr_assigned_to_reviewers
      on_validation_pass: proceed_to_code_reviewer_pr_review
      next_step_automatic: code_reviewer_pr_review
      creates: pull_request
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates SM to create PR
        - SM creates PR: feature/story-{epic}-{story} ‚Üí main
        - SM includes: story summary, AC checklist, test results, changed files
        - SM hands back: {pr_created: true, pr_number: int, pr_url: "..."}
        - Orchestrator validates PR creation
        - Orchestrator IMMEDIATELY proceeds to code_reviewer_pr_review

    - step: code_reviewer_pr_review
      agent: code-reviewer
      action: comprehensive 8-step PR review with approval authority
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - pr_review_complete
        - security_scan_performed
        - decision_made
      on_validation_pass_approved: proceed_to_bmad_pr_approval_or_merge
      on_validation_fail_changes_requested: return_to_pr_changes_requested
      next_step_automatic: bmad_pr_approval_or_pr_changes
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates code-reviewer for comprehensive PR review
        - Code-reviewer performs 8-step review: context, changes, security, quality, tests, performance, docs, decision
        - Code-reviewer hands back: {
            review_complete: true,
            decision: "approved" | "request_changes" | "comment",
            critical_issues: [...],
            warnings: [...],
            can_merge: boolean
          }
        - Orchestrator validates review decision
        - If approved ‚Üí Orchestrator proceeds to bmad_pr_approval
        - If changes requested ‚Üí Orchestrator activates pr_changes_requested
        - Orchestrator manages review cycle autonomously

    - step: pr_changes_requested
      agent: dev
      action: address PR feedback from code-reviewer
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: code_reviewer_requested_changes
      orchestrator_validates:
        - changes_addressed
        - updates_pushed_to_branch
        - ready_for_re_review
      on_validation_pass: return_to_qa_verify_pr_changes
      next_step_automatic: qa_verify_pr_changes
      notes: |
        ORCHESTRATOR CONTROL POINT (TRIGGERED BY CHANGES REQUESTED):
        - Orchestrator activates Dev with specific feedback from code-reviewer
        - Dev addresses: critical issues, warnings, suggestions
        - Dev hands back: {changes_complete: true, addressed_issues: [...]}
        - Orchestrator validates changes
        - Orchestrator triggers qa_verify_pr_changes to ensure no breakage

    - step: qa_verify_pr_changes
      agent: qa
      action: verify PR changes don't break functionality
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: pr_changes_made
      orchestrator_validates:
        - pr_changes_tested
        - no_regressions_introduced
        - all_tests_still_passing
      on_validation_pass: return_to_code_reviewer_pr_review
      next_step_automatic: code_reviewer_pr_review_rereview
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates QA to verify PR changes
        - QA tests: modified areas, regression tests, full test suite
        - QA hands back: {changes_verified: boolean, new_issues: [...]}
        - Orchestrator validates QA results
        - Orchestrator returns to code_reviewer_pr_review for re-review
        - Loop continues until PR approved

    - step: bmad_pr_approval
      agent: bmad-master
      action: final oversight and merge PR to main
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: code_reviewer_approved_and_all_checks_pass
      orchestrator_validates:
        - pr_merged_successfully
        - feature_branch_deleted
        - main_branch_updated
      on_validation_pass: proceed_to_story_retrospective
      next_step_automatic: story_retrospective
      merges: pull_request
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates BMad Master for final oversight
        - BMad Master verifies: code-reviewer approval, tests pass, ready to merge
        - BMad Master merges PR to main, deletes feature branch
        - BMad Master hands back: {merged: true, commit_sha: "...", story_complete: true}
        - Orchestrator validates merge success
        - Orchestrator IMMEDIATELY proceeds to story_retrospective
        - NO USER CELEBRATION PAUSE - Continuous execution

    - step: story_retrospective
      agent: sm
      action: document story completion, metrics, and learnings
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - retrospective_documented
        - metrics_recorded
        - lessons_learned_captured
      on_validation_pass: proceed_to_next_story_decision
      next_step_automatic: next_story_decision
      notes: |
        ORCHESTRATOR CONTROL POINT:
        - Orchestrator activates SM to document retrospective
        - SM records: completion time, lessons learned, velocity, technical debt
        - SM updates: story document with retrospective section
        - SM hands back: {
            retrospective_complete: true,
            story_duration: "...",
            velocity_metrics: {...},
            next_story_ready: true
          }
        - Orchestrator validates retrospective completion
        - Orchestrator IMMEDIATELY proceeds to next_story_decision
        - üö® CRITICAL: NO "Would you like to continue?" prompt here

    - step: next_story_decision
      agent: orchestrator-self
      action: autonomous decision on next story or epic transition
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      orchestrator_validates:
        - backlog_reviewed
        - next_action_determined
        - no_user_input_requested
      on_more_stories_in_epic: return_to_story_selection
      on_epic_complete: proceed_to_epic_completion
      on_all_complete: proceed_to_project_completion
      next_step_automatic: story_selection_or_epic_completion_or_project_completion
      notes: |
        üö® CRITICAL ORCHESTRATOR CONTROL POINT - AUTONOMOUS DECISION:

        Orchestrator makes decision autonomously (NO agent activation needed):

        1. Orchestrator checks: remaining stories in current epic
        2. Orchestrator checks: remaining epics in project

        DECISION LOGIC (FULLY AUTONOMOUS):

        IF more stories in current epic:
          - Orchestrator logs: "Story X.Y complete. Proceeding to Story X.(Y+1)"
          - Orchestrator IMMEDIATELY returns to story_selection step
          - NO USER PROMPT: "Continue to next story?"
          - NO OPTIONS PRESENTED
          - IMMEDIATE CONTINUATION

        IF current epic complete AND more epics remaining:
          - Orchestrator logs: "Epic X complete (Z/Z stories). Starting Epic X+1"
          - Orchestrator proceeds to epic_completion step
          - Then IMMEDIATELY to story_selection for next epic
          - NO USER PROMPT: "Start next epic?"
          - AUTOMATIC EPIC TRANSITION

        IF all 6 epics complete (28 stories total):
          - Orchestrator logs: "All epics complete. Performing project completion."
          - Orchestrator proceeds to project_completion step
          - This is the ONLY termination point

        Orchestrator hands back to self: {
          decision: "next_story" | "epic_transition" | "project_complete",
          next_epic: int | null,
          next_story: int | null
        }

        üö® REMEMBER: Orchestrator INFORMS user of actions, NEVER asks permission
        ‚úÖ "Proceeding to Story 2.1" (correct)
        ‚ùå "Continue to Story 2.1? Y/N" (wrong - never ask)

    - step: epic_completion
      agent: pm
      action: document epic completion and achievements
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: all_stories_in_epic_complete
      orchestrator_validates:
        - epic_summary_created
        - all_epic_stories_verified_complete
        - epic_metrics_recorded
      on_validation_pass: proceed_to_story_selection_next_epic
      next_step_automatic: story_selection
      creates: docs/epics/epic-{epic}-summary.md
      notes: |
        ORCHESTRATOR CONTROL POINT (EPIC TRANSITION):
        - Orchestrator activates PM when all stories in epic are merged
        - PM creates epic summary: achievements, metrics, challenges
        - PM hands back: {
            epic_complete: true,
            epic_number: int,
            stories_completed: int,
            next_epic_ready: boolean
          }
        - Orchestrator validates epic completion
        - Orchestrator IMMEDIATELY proceeds to story_selection for NEXT epic
        - üö® CRITICAL: NO "Start next epic?" prompt
        - Orchestrator logs: "Epic X complete. Starting Epic X+1"
        - AUTOMATIC CONTINUATION WITHOUT USER INPUT

    - step: project_completion
      agent: bmad-master
      action: final project review and documentation
      orchestrated_by: bmad-orchestrator
      handback_to_orchestrator: true
      condition: all_28_stories_complete
      orchestrator_validates:
        - all_epics_verified_complete
        - project_summary_created
        - final_deliverables_documented
      on_validation_pass: terminate_workflow_with_success
      creates: docs/project-summary.md
      notes: |
        ORCHESTRATOR CONTROL POINT (FINAL):
        - Orchestrator activates BMad Master when all 6 epics complete (28 stories)
        - BMad Master creates: comprehensive project summary, metrics, deliverables
        - BMad Master hands back: {
            project_complete: true,
            all_stories_merged: true,
            system_operational: boolean
          }
        - Orchestrator validates project completion
        - Orchestrator terminates workflow with success status
        - This is the ONLY stopping point in the entire workflow

  orchestrator_state_machine:
    state_tracking: |
      The bmad-orchestrator maintains persistent state throughout execution:

      STATE STRUCTURE:
        {
          current_epic: int (1-6),
          current_story: int (varies per epic),
          current_step: string (workflow step id),
          total_stories_completed: int (0-28),
          epics_completed: int (0-6),
          current_story_status: {
            step_completed: [...],
            step_in_progress: string,
            quality_gates_passed: [...],
            retry_count: int
          },
          workflow_status: "active" | "paused" | "complete" | "error"
        }

      STATE TRANSITIONS (ALL AUTOMATIC):
        - Story complete ‚Üí Increment total_stories_completed
        - Epic complete ‚Üí Increment epics_completed, reset current_story to 1
        - Quality gate fail ‚Üí Increment retry_count, activate fix step
        - Quality gate pass ‚Üí Mark step complete, activate next step
        - All epics complete ‚Üí Set workflow_status: "complete"

      DECISION POINTS (Based on state):
        - If current_story < epic_total ‚Üí Next story in epic
        - If current_story == epic_total ‚Üí Epic complete, proceed to next epic
        - If epics_completed == 6 ‚Üí Project complete

      NO USER INPUT AFFECTS STATE - All transitions are orchestrator-controlled

  agent_handback_protocol:
    standard_handback_format: |
      Every agent must hand back control using this format:

      {
        agent_id: "string (sm|dev|qa|architect|code-reviewer|pm|bmad-master)",
        step_id: "string (workflow step identifier)",
        step_status: "completed" | "failed" | "blocked",
        quality_gates_status: {
          gate_name: boolean,
          ...
        },
        output_data: {
          ... (step-specific data for next steps)
        },
        issues_found: [...] or null,
        recommended_next_step: "string (step id)",
        handback_timestamp: "ISO8601 datetime"
      }

      AGENT RESPONSIBILITY:
        - Complete assigned task
        - Validate own work against quality criteria
        - Package results in handback format
        - Signal completion to orchestrator
        - STOP and wait for next activation
        - NEVER proceed to next step independently
        - NEVER ask user for direction

      ORCHESTRATOR RESPONSIBILITY:
        - Receive handback
        - Validate against quality gates
        - Make decision on next step
        - Activate next agent/step
        - Update workflow state
        - Log progression
        - NEVER ask user for continuation approval

  quality_gates:
    orchestrator_enforced_gates:
      before_code_review:
        - unit_tests_passing: true
        - code_coverage_minimum: 90
        - quality_tools_passed: [ruff, black, mypy]
        - all_files_committed: true
        - enforced_by: orchestrator
        - on_fail: return_to_dev_with_issues

      before_qa_handoff:
        - security_scan_passed: true
        - no_critical_security_issues: true
        - code_review_approved: true
        - enforced_by: orchestrator
        - on_fail: return_to_dev_fixes

      before_pr_creation:
        - all_acceptance_criteria_met: true
        - all_tests_passing: true
        - code_coverage_maintained: 90
        - architect_approved: true
        - sm_approved: true
        - enforced_by: orchestrator
        - on_fail: return_to_failing_step

      before_pr_merge:
        - code_reviewer_approved: true
        - all_ci_checks_passed: true
        - no_merge_conflicts: true
        - qa_verified_pr_changes: true
        - enforced_by: orchestrator
        - on_fail: return_to_pr_changes

      before_next_story:
        - previous_story_merged: true
        - retrospective_documented: true
        - no_blocking_issues: true
        - enforced_by: orchestrator
        - on_fail: resolve_blockers_before_proceeding

  continuous_execution_guarantees:
    no_pause_points: |
      The following are NOT pause points (workflow continues automatically):

      1. After story planning ‚Üí IMMEDIATE implementation start
      2. After code implementation ‚Üí IMMEDIATE code review
      3. After code review approval ‚Üí IMMEDIATE QA testing
      4. After QA pass ‚Üí IMMEDIATE architect review
      5. After architect approval ‚Üí IMMEDIATE SM approval
      6. After SM approval ‚Üí IMMEDIATE PR creation
      7. After PR approval ‚Üí IMMEDIATE merge
      8. After merge ‚Üí IMMEDIATE retrospective
      9. After retrospective ‚Üí IMMEDIATE next story selection ‚Üê CRITICAL
      10. After epic complete ‚Üí IMMEDIATE next epic start ‚Üê CRITICAL

      The orchestrator NEVER pauses to ask:
      - "Ready to implement?"
      - "Should I create PR?"
      - "Continue to next story?"
      - "Start next epic?"
      - "Would you like me to..."
      - Any variation of asking for permission to proceed

    continuous_loop_structure: |
      OUTER LOOP (Epic level):
        FOR epic IN 1..6:
          INNER LOOP (Story level):
            FOR story IN epic.stories:
              EXECUTE story_workflow_cycle(epic, story)
              WAIT FOR merge_complete
              EXECUTE retrospective
              # üö® NO USER PROMPT HERE - IMMEDIATE CONTINUATION
              IF more_stories_in_epic:
                CONTINUE (loop to next story)
              ELSE:
                BREAK (exit to epic completion)
          EXECUTE epic_completion
          # üö® NO USER PROMPT HERE - IMMEDIATE CONTINUATION
          IF epic < 6:
            CONTINUE (loop to next epic)
        EXECUTE project_completion
        TERMINATE

      GUARANTEES:
        - Zero manual intervention points
        - Zero "continue?" prompts
        - Zero option menus presented
        - Continuous execution until complete
        - Orchestrator makes ALL decisions
        - User observes, does not direct

  agent_responsibilities:
    scrum_master:
      - Story selection (hands back: selected story)
      - Story planning (hands back: story document)
      - Story approval (hands back: approval status)
      - PR creation (hands back: PR number and URL)
      - Retrospective (hands back: completion confirmation)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user "continue?"

    developer:
      - TDD implementation (hands back: code + tests + coverage)
      - Code quality validation (hands back: validation results)
      - Issue fixes (hands back: fixes complete status)
      - PR changes (hands back: changes addressed)
      - ALWAYS hands back control to orchestrator
      - NEVER proceeds to next step independently

    code_reviewer:
      - Security scan (hands back: scan results + approval/denial)
      - Code quality review (hands back: review decision)
      - PR review (hands back: approve/request changes/comment)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user for merge approval

    qa_tester:
      - Acceptance testing (hands back: test results + pass/fail per criterion)
      - Regression testing (hands back: regression status)
      - PR change verification (hands back: verification status)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user if tests are sufficient

    technical_architect:
      - Architecture review (hands back: approval + notes)
      - Final implementation review (hands back: approval status)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user for architecture decisions

    product_manager:
      - Epic completion (hands back: epic summary + next epic readiness)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user "start next epic?"

    bmad_master:
      - PR merge (hands back: merge success + commit SHA)
      - Project completion (hands back: final summary)
      - ALWAYS hands back control to orchestrator
      - NEVER asks user for merge confirmation

  story_progress_tracking:
    epic_1_foundation:
      total_stories: 5
      stories:
        - "1.1: Project Setup and Dependencies"
        - "1.2: Configuration System"
        - "1.3: DuckDB Schema Implementation"
        - "1.4: LinkedIn Job Poller (Basic)"
        - "1.5: Job Queue System"

    epic_2_core_agents:
      total_stories: 8
      stories:
        - "2.1: Agent Base Class and Infrastructure"
        - "2.2: Job Matcher Agent"
        - "2.3: Salary Validator Agent"
        - "2.4: CV Tailor Agent"
        - "2.5: Cover Letter Writer Agent"
        - "2.6: QA Agent"
        - "2.7: Orchestrator Agent"
        - "2.8: Checkpoint System"

    epic_3_duplicate_detection:
      total_stories: 3
      stories:
        - "3.1: Tier 1 Exact Duplicate Detection"
        - "3.2: Tier 2 Fuzzy Duplicate Detection"
        - "3.3: Duplicate Group Management"

    epic_4_application_submission:
      total_stories: 3
      stories:
        - "4.1: Email Submission Handler"
        - "4.2: Web Form Submission Handler"
        - "4.3: Submission Status Tracking"

    epic_5_gradio_ui:
      total_stories: 5
      stories:
        - "5.1: Gradio Dashboard Setup"
        - "5.2: Job Queue Monitor"
        - "5.3: Application Review Interface"
        - "5.4: Document Preview"
        - "5.5: Manual Controls"

    epic_6_testing_refinement:
      total_stories: 4
      stories:
        - "6.1: End-to-End Testing"
        - "6.2: Performance Optimization"
        - "6.3: Error Handling Improvements"
        - "6.4: Documentation Finalization"

    total_mvp_stories: 28
    completion_tracking: "Orchestrator maintains state automatically"

  execution_examples:
    correct_autonomous_flow: |
      ‚úÖ CORRECT ORCHESTRATOR BEHAVIOR:

      [Story 1.5 retrospective complete]
      Orchestrator: "Story 1.5 complete. Epic 1 Foundation: 5/5 stories merged."
      Orchestrator: "Proceeding to Epic 2: Core Agents, Story 2.1 (Agent Base Class)"
      Orchestrator: [Activates SM for story_selection with epic=2, story=1]
      SM: [Selects Story 2.1, creates plan, hands back to orchestrator]
      Orchestrator: "Story 2.1 selected. Proceeding to implementation."
      Orchestrator: [Activates Dev for story_implementation]
      ... (workflow continues)

      Note: Zero user prompts, continuous execution, orchestrator always in control

    incorrect_user_prompting: |
      ‚ùå WRONG BEHAVIOR (Never do this):

      [Story 1.5 retrospective complete]
      Agent: "Epic 1 is now complete! Great work! üéâ"
      Agent: "We have several options for what to do next:"
      Agent: "A) Continue to Epic 2 (Core Agents)"
      Agent: "B) Review what we built so far"
      Agent: "C) Take a break and continue later"
      Agent: "What would you like to do?"

      This is WRONG because:
      - Presents options to user (orchestrator decides, not user)
      - Asks for user input (fully autonomous means no user input)
      - Pauses execution waiting for response (should continue immediately)
      - Agent making decisions instead of orchestrator

    correct_epic_transition: |
      ‚úÖ CORRECT EPIC TRANSITION:

      [Story 1.5 merged and retrospective complete]
      Orchestrator: [Checks: more stories in Epic 1? No. More epics? Yes.]
      Orchestrator: [Activates PM for epic_completion with epic=1]
      PM: [Creates epic summary, hands back: epic_complete=true, next_epic_ready=true]
      Orchestrator: "Epic 1 complete (5/5 stories). Starting Epic 2."
      Orchestrator: [Immediately activates SM for story_selection with epic=2]
      SM: [Selects Story 2.1, hands back]
      Orchestrator: "Story 2.1 selected. Proceeding to planning."
      ... (workflow continues)

      Note: No pause, no user prompt, immediate transition
