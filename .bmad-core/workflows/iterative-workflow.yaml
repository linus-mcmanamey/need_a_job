# <!-- Powered by BMADâ„¢ Core -->
# Job Application Automation System - Iterative Story Development
# Project: need_a_job
# Tech Stack: Python 3.11+, FastAPI, Redis+RQ, DuckDB, Gradio, Claude LLM
#
# ========================================================================
# FULLY AUTONOMOUS WORKFLOW - NO USER INTERACTION REQUIRED
# ========================================================================
# This workflow is controlled entirely by the bmad-orchestrator.
# The orchestrator autonomously manages all 28 user stories across 6 epics.
# NO user interaction is required to start epics or user stories.
# Agents continue execution until ALL epics and stories are complete.
#
# ORCHESTRATION MODEL:
#   - bmad-orchestrator controls all flow operations
#   - Automatic story selection and sequencing (1.1 â†’ 1.2 â†’ ... â†’ 6.4)
#   - Automatic epic transitions (Epic 1 â†’ Epic 2 â†’ ... â†’ Epic 6)
#   - Automatic quality gate enforcement and retry loops
#   - Autonomous decision-making at all checkpoints
#   - Continuous execution until project completion (28 stories merged)
#
# EXECUTION FLOW:
#   Prerequisites Check â†’ Story Selection â†’ Planning â†’ Implementation (TDD) â†’
#   Code Review & Security Scan â†’ QA Testing â†’ Fix Cycles (auto-retry) â†’
#   Architecture Review â†’ PR Creation â†’ Code-Reviewer PR Review â†’
#   BMad Final Oversight â†’ Merge â†’ Retrospective â†’ Next Story (auto-continue)
#
# TERMINATION: Workflow completes only when all 6 epics are done.
# ========================================================================

workflow:
  id: iterative-story-development
  name: Job Application Automation - Iterative Story Development
  description: >-
    FULLY AUTONOMOUS agent workflow for iterative development of the automated job application system.
    The bmad-orchestrator controls all flow operations and agents continue execution until ALL epics
    and user stories are complete. NO USER INTERACTION REQUIRED. Each story from the PRD epics is
    fully developed, tested with pytest achieving 90% code coverage, and merged before the next story begins.
    The system includes 7 AI agents (Job Matcher, Salary Validator, CV Tailor, Cover Letter Writer, QA,
    Orchestrator, Application Handler) that process jobs through a pipeline. Stories are developed by the
    BMad dev agent, validated by the BMad QA agent, and reviewed by the BMad architect before merge.
    The bmad-orchestrator autonomously selects and sequences all stories across all 6 epics until project completion.
  type: iterative
  automation_mode: fully_autonomous
  orchestration_control: bmad-orchestrator
  execution_policy: continue_until_all_complete
  project_types:
    - python-development
    - fastapi-backend
    - llm-integration
    - agile-development
    - story-driven-development
    - multi-agent-system

  orchestration_strategy:
    controller: bmad-orchestrator
    execution_mode: fully_autonomous
    user_interaction: none_required
    continuation_policy: execute_until_all_complete

    process_control: |
      The bmad-orchestrator controls all workflow operations through the following autonomous process:

      1. INITIALIZATION PHASE (Automatic):
         - Verify prerequisites without user confirmation
         - Load PRD epic definitions from docs/prd/
         - Initialize story tracking (28 total MVP stories across 6 epics)
         - Set execution state: Epic 1, Story 1.1

      2. STORY EXECUTION LOOP (Continuous):
         For each story in sequential order (1.1 â†’ 1.2 â†’ ... â†’ 6.4):
           a. Story Selection: SM autonomously selects next story
           b. Story Planning: SM creates implementation plan
           c. Architecture Review: Architect reviews if needed (conditional)
           d. TDD Implementation: Dev implements with tests (90% coverage minimum)
           e. Quality Validation: Dev validates code quality gates
           f. Code Review & Security Scan: Code-reviewer performs security and quality review
           g. QA Testing: QA validates all acceptance criteria
           h. Fix Cycle: Dev fixes issues, QA retests (iterate until pass)
           i. Final Review: Architect approves implementation
           j. SM Approval: SM verifies story completion
           k. PR Creation: SM creates pull request
           l. Code-Reviewer PR Review: Code-reviewer performs comprehensive PR review with approval authority
           m. PR Changes: Dev addresses feedback if needed (conditional)
           n. BMad Final Oversight: BMad Master verifies and merges (or validates merge)
           o. Retrospective: SM documents completion

      3. EPIC TRANSITION (Automatic):
         When all stories in current epic complete:
           - PM documents epic completion
           - bmad-orchestrator automatically proceeds to next epic
           - No user approval needed
           - Process continues with next epic's Story X.1

      4. PROJECT COMPLETION (Final):
         When all 6 epics complete (28 stories total):
           - BMad Master performs final project review
           - Generate comprehensive project summary
           - Workflow terminates with success

      5. ERROR HANDLING (Autonomous):
         - Quality gate failures: Automatically return to previous step
         - Test failures: Automatically trigger fix cycle (dev â†’ qa loop)
         - Merge conflicts: Automatically attempt resolution or flag for dev
         - Critical failures: Log issue, attempt auto-remediation, continue if possible

      6. DECISION POINTS (All Automatic):
         - Complex story needs analysis? â†’ Analyst step (conditional, auto-triggered)
         - Architectural changes needed? â†’ Architect review (conditional, auto-triggered)
         - QA tests failed? â†’ Dev fixes step (conditional, auto-triggered)
         - PR changes requested? â†’ Dev fixes + QA retest (conditional, auto-triggered)
         - More stories in epic? â†’ Loop to story_selection (automatic)
         - Epic complete? â†’ Epic completion â†’ Next epic (automatic)
         - All epics complete? â†’ Project completion (automatic)

      CONTINUOUS OPERATION: The bmad-orchestrator maintains execution state and ensures
      uninterrupted progress through all 28 stories until project completion. Agents are
      activated in sequence based on workflow steps, complete their tasks, and hand off
      to the next agent automatically.

  sequence:
    - step: prerequisites_check
      agent: sm
      action: verify prerequisites and environment
      orchestrated_by: bmad-orchestrator
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator initiates and monitors this step.

        Scrum Master autonomously verifies before starting:
        - Python 3.11+ environment configured
        - Redis server running for job queue (docker or local)
        - DuckDB database initialized (data/jobs.duckdb)
        - All dependencies from requirements.txt installed
        - Configuration files present (search.yaml, agents.yaml, platforms.yaml)
        - PRD at docs/prd/ directory with all epic files
        - Architecture docs at docs/architecture/
        - LinkedIn MCP server configured in .mcp.json
        - All unit tests from previous story passed with 90% coverage

        NO USER INTERACTION: bmad-orchestrator automatically proceeds to story_selection once prerequisites are verified.
        If prerequisites fail, orchestrator logs issues and attempts auto-remediation where possible.

    - step: story_selection
      agent: sm
      action: select next story from PRD epics
      orchestrated_by: bmad-orchestrator
      reviews:
        - docs/prd/epic-*.md
        - docs/prd/7-implementation-roadmap.md
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator directs SM to autonomously select the next story in sequence.

        SM automatically selects the next story from PRD epic sequence following strict sequential order:
        - Epic 1: Foundation (Stories 1.1-1.5)
        - Epic 2: Core Agents (Stories 2.1-2.8)
        - Epic 3: Duplicate Detection (Stories 3.1-3.3)
        - Epic 4: Application Submission (Stories 4.1-4.3)
        - Epic 5: Gradio UI (Stories 5.1-5.5)
        - Epic 6: Testing & Refinement (Stories 6.1-6.4)

        PROCESS FOLLOWED:
        1. Check completed stories in docs/stories/ directory
        2. Identify next incomplete story based on epic/story numbering
        3. Verify all prerequisite stories are complete
        4. Automatically create feature branch: feature/story-{epic}-{story}
        5. Proceed to story_planning step without user confirmation

        bmad-orchestrator ensures continuous flow through all 28 MVP stories until project completion.

    - step: story_planning
      agent: sm
      action: review story acceptance criteria and create implementation plan
      orchestrated_by: bmad-orchestrator
      reviews:
        - docs/prd/epic-{epic}.md
        - docs/architecture/7-agent-architecture.md
        - docs/architecture/12-technology-stack.md
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator directs SM to autonomously plan the selected story.

        SM autonomously reviews story from PRD epic file:
        - Read story definition, acceptance criteria, technical notes
        - Verify dependencies from previous stories are met
        - Identify technical tasks for implementation
        - Review relevant architecture patterns
        - Create detailed user story at docs/stories/{epic}.{story}.{title}.md
        - Create implementation checklist with tasks/subtasks
        - Include test coverage requirements (90% minimum)
        - Define integration points with existing agents/services

        Story document should include:
        - Story description and context
        - Acceptance criteria (from PRD)
        - Implementation tasks breakdown
        - Testing strategy
        - API endpoints to create/modify (if applicable)
        - Database schema changes (if applicable)
        - Agent modifications (if applicable)
        - Dependencies and prerequisites

    - step: requirements_clarification
      agent: analyst
      action: clarify requirements and edge cases
      reviews:
        - docs/stories/{epic}.{story}.{title}.md
        - docs/prd/epic-{epic}.md
      condition: complex_story_needs_analysis
      notes: |
        Business Analyst clarifies:
        - Edge cases and error scenarios
        - Integration points with LinkedIn MCP
        - Data validation requirements
        - User experience considerations (for UI stories)
        - Business logic for agent decision-making
        - Duplicate detection thresholds (for Epic 3)
        - Form submission strategies (for Epic 4)

        Output:
        - Updated story document with clarifications
        - Additional acceptance criteria if needed
        - Risk analysis for complex features

    - step: architecture_review
      agent: architect
      action: review technical design and patterns
      reviews:
        - docs/stories/{epic}.{story}.{title}.md
        - docs/architecture/
      condition: architectural_changes_needed
      notes: |
        Technical Architect reviews:
        - System design and component architecture
        - Database schema changes (DuckDB)
        - Agent pipeline modifications
        - API design (FastAPI endpoints)
        - Integration patterns (MCP servers, Redis queue)
        - Performance considerations
        - Security requirements

        For agent stories (Epic 2):
        - Agent class structure (BaseAgent inheritance)
        - Claude model selection rationale
        - AgentResult output schema
        - Checkpoint/resume implementation

        Output:
        - Architecture notes added to story document
        - Component diagrams if needed
        - Technical debt considerations
        - Approval to proceed or request clarifications

    - step: story_implementation
      agent: dev
      action: implement story using Test-Driven Development (TDD)
      orchestrated_by: bmad-orchestrator
      creates: implementation_files
      requires: docs/stories/{epic}.{story}.{title}.md
      branch: feature/story-{epic}-{story}
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator initiates TDD implementation cycle for the story.

        Developer autonomously implements story using TDD methodology:

        **SETUP:**
        - Read story requirements in docs/stories/{epic}.{story}.{title}.md
        - Review relevant architecture docs
        - Understand existing codebase structure

        **FOR EACH ACCEPTANCE CRITERION - Follow TDD Cycle:**

        1. RED PHASE - Write failing tests first:
           * Write unit tests using pytest
           * Tests should fail initially (no implementation yet)
           * Include edge cases, error scenarios, input validation
           * Create test files in tests/ directory
           * Use appropriate fixtures and mocks

        2. GREEN PHASE - Write minimal code to pass:
           * Implement just enough code to make tests pass
           * For Epic 1 stories: Database operations, configuration loading, job polling
           * For Epic 2 stories: Agent classes, Claude API integration, checkpoint system
           * For Epic 3 stories: Duplicate detection algorithms, similarity scoring
           * For Epic 4 stories: Form submission, email sending, Playwright automation
           * For Epic 5 stories: Gradio UI components, real-time dashboards
           * Run tests: pytest tests/ -v

        3. REFACTOR PHASE - Improve code quality:
           * Refactor while keeping tests green
           * Follow Python best practices and type hints
           * Ensure clean architecture and maintainability
           * Use proper error handling and logging (loguru)

        4. VERIFY & DOCUMENT:
           * Run full test suite: pytest tests/ --cov=app --cov-report=term
           * Check coverage: Must achieve minimum 90% code coverage
           * Update docs/stories/{epic}.{story}.{title}.md with:
             - Test files created
             - Coverage percentage achieved
             - Mark acceptance criterion as complete [x]

        **INTEGRATION TESTING:**
        - FastAPI endpoints: Test with FastAPI TestClient
        - Database operations: Test DuckDB queries and schema
        - Redis queue: Test job enqueue/dequeue operations
        - Agent pipeline: Test agent execution and checkpointing
        - LinkedIn MCP: Test job discovery integration
        - Claude API: Test prompt/response handling

        **MANDATORY BEFORE HANDOFF TO QA:**
        * All unit tests must pass (100% pass rate)
        * Code coverage must be â‰¥90%
        * All acceptance criteria have corresponding tests
        * Test results documented in story file
        * Code follows project structure (app/, tests/, config/)
        * Type hints added (run mypy for validation)
        * Logging added for debugging

        Commit all code and tests with descriptive messages

    - step: code_quality_validation
      agent: dev
      action: validate code quality and test coverage
      validates: code_quality_gates
      required_before: code_review_security_scan
      notes: |
        Developer validates before code review:

        **CODE QUALITY CHECKS:**
        - Run linter: ruff check app/ tests/
        - Run formatter: black --check app/ tests/
        - Run type checker: mypy app/
        - Fix any issues found

        **TEST VALIDATION:**
        - Run full test suite: pytest tests/ -v
        - Generate coverage report: pytest --cov=app --cov-report=html
        - Verify metrics:
          * All unit tests passing (100% pass rate)
          * Code coverage â‰¥90% overall
          * Each acceptance criterion has corresponding tests
          * No untested public methods or classes

        **DOCUMENTATION:**
        - Update docs/stories/{epic}.{story}.{title}.md:
          * Test execution results
          * Coverage percentage achieved
          * List of test files created
          * Any known limitations or edge cases

        **MANUAL TESTING:**
        - Test FastAPI endpoints manually (if applicable)
        - Test agent execution with sample jobs (if applicable)
        - Verify Redis queue operations (if applicable)
        - Check DuckDB database state (if applicable)

        If validation fails:
        - Return to TDD cycle
        - Write missing tests
        - Fix code quality issues
        - Achieve required coverage

        Only proceed to code review when all gates pass

    - step: code_review_security_scan
      agent: code-reviewer
      action: comprehensive code quality and security review
      orchestrated_by: bmad-orchestrator
      reviews: implementation_files
      required_before: qa_testing_cycle
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator assigns code review to code-reviewer agent automatically.

        Code Reviewer (Alex) autonomously performs comprehensive review:

        **SECURITY SCAN (Critical Priority):**
        - ðŸš¨ Search for exposed secrets/API keys/tokens/passwords
        - ðŸš¨ Check for SQL injection vulnerabilities (DuckDB queries)
        - ðŸš¨ Check for command injection risks
        - ðŸš¨ Validate input sanitization and validation
        - ðŸš¨ Review authentication/authorization logic
        - ðŸš¨ Check error messages don't leak sensitive info

        **CODE QUALITY REVIEW:**
        - Functions/variables have clear, descriptive names
        - No duplicated code (DRY principle)
        - Proper error handling for external calls
        - Type hints present and correct
        - No TODO comments without tickets
        - Algorithmic complexity reasonable (no O(nÂ²) where avoidable)

        **TESTING VALIDATION:**
        - Review test coverage adequacy (â‰¥90%)
        - Validate edge cases covered
        - Check test quality and maintainability
        - Verify integration tests appropriate

        **PERFORMANCE REVIEW:**
        - Database queries optimized (no N+1 problems)
        - Resource usage appropriate
        - Async/await patterns used correctly
        - No memory leaks or resource exhaustion risks

        **DOCUMENTATION CHECK:**
        - Docstrings present for public APIs
        - Complex logic explained
        - Architecture patterns followed

        **REVIEW OUTPUT:**
        - Document findings by priority:
          * ðŸš¨ CRITICAL: Must fix before QA (blocks QA handoff)
          * âš ï¸ WARNING: Should fix (advisory, document in story)
          * ðŸ’¡ SUGGESTION: Consider improving (optional, document in story)

        **DECISION:**
        - APPROVE: No critical issues â†’ Proceed to QA
        - REQUEST CHANGES: Critical issues found â†’ Return to Dev with specific feedback
        - Update docs/stories/{epic}.{story}.{title}.md with review findings

    - step: qa_testing_cycle
      agent: qa
      action: verify all acceptance criteria and quality standards
      orchestrated_by: bmad-orchestrator
      updates: docs/stories/{epic}.{story}.{title}.md
      requires:
        - docs/prd/epic-{epic}.md
        - code_quality_validation
      iterates: until_all_criteria_pass
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator manages QA testing cycle and automatic iteration.

        QA Agent autonomously tests each acceptance criterion from PRD:

        **FIRST - Verify test coverage from Dev:**
        - Confirm code quality validation gate passed
        - Review coverage report in docs/stories/{epic}.{story}.{title}.md
        - Verify â‰¥90% code coverage achieved
        - Check all acceptance criteria have unit tests
        - If unit tests insufficient:
          * REJECT handoff back to Dev
          * List missing test scenarios
          * Require completion of TDD cycle

        **THEN - Perform integration and acceptance testing:**

        **For Foundation Stories (Epic 1):**
        - Test configuration loading (search.yaml, agents.yaml, platforms.yaml)
        - Test DuckDB database operations (CRUD, indexes, queries)
        - Test LinkedIn job polling and data extraction
        - Test Redis queue enqueue/dequeue operations
        - Test RQ worker job processing
        - Verify job flow: poller â†’ database â†’ queue

        **For Agent Stories (Epic 2):**
        - Test each agent individually with sample jobs
        - Test agent pipeline execution (sequential processing)
        - Test JobMatcherAgent scoring logic
        - Test CVTailorAgent document generation
        - Test CoverLetterWriterAgent personalization
        - Test QAAgent validation checks
        - Test OrchestratorAgent decision-making
        - Test checkpoint/resume functionality
        - Verify generated CV/CL files in export directory
        - Test error handling and retry logic

        **For Duplicate Detection Stories (Epic 3):**
        - Test Tier 1 exact duplicate detection
        - Test Tier 2 fuzzy matching algorithms
        - Test similarity scoring and thresholds
        - Test duplicate group assignment
        - Verify database duplicate_group_id updates

        **For Submission Stories (Epic 4):**
        - Test email submission with test accounts
        - Test web form detection and automation
        - Test Playwright/Chrome MCP integration
        - Test submission status tracking

        **For UI Stories (Epic 5):**
        - Test Gradio dashboard launch
        - Test real-time job display and filters
        - Test manual approval/rejection controls
        - Test document preview functionality
        - Test UI responsiveness and usability

        **DOCUMENT RESULTS:**
        - Update docs/stories/{epic}.{story}.{title}.md with testing notes
        - For each acceptance criterion:
          * âœ… PASS: Criterion met with evidence
          * âŒ FAIL: Issue description with logs/screenshots
          * âš ï¸ BLOCKED: External dependency issue
        - Include test execution logs
        - Include screenshots (for UI stories)
        - Include performance metrics (if applicable)

        **REGRESSION TESTING:**
        - Run full test suite to ensure no breakage
        - Test previously completed stories still work
        - Verify integration with existing components

        Return to Dev if any criterion fails or unit tests inadequate

    - step: dev_fixes
      agent: dev
      action: fix failing tests and issues
      updates: docs/stories/{epic}.{story}.{title}.md
      condition: qa_tests_failed
      notes: |
        Developer fixes issues found by QA:

        **REVIEW QA FEEDBACK:**
        - Read QA test results in docs/stories/{epic}.{story}.{title}.md
        - Prioritize failing acceptance criteria
        - Understand root causes of failures

        **FIX IMPLEMENTATION:**
        - Fix code to address failing tests
        - Add missing functionality
        - Improve error handling
        - Update unit tests if needed

        **RE-TEST LOCALLY:**
        - Run unit tests: pytest tests/ -v
        - Run integration tests for fixed areas
        - Verify fixes don't break existing functionality
        - Test specific failing scenarios from QA report
        - Achieve â‰¥90% coverage

        **UPDATE DOCUMENTATION:**
        - Update docs/stories/{epic}.{story}.{title}.md:
          * Mark reopened tasks
          * Add fix notes and explanations
          * Document any technical debt created

        **NOTIFY QA:**
        - Commit fixes with descriptive messages
        - Mark ready for QA re-test
        - Provide summary of changes made

    - step: qa_retest
      agent: qa
      action: retest fixes and verify resolution
      updates: docs/stories/{epic}.{story}.{title}.md
      condition: after_dev_fixes
      notes: |
        QA Agent retests after Dev fixes:

        **FOCUSED RE-TESTING:**
        - Focus on previously failing tests
        - Test specific fixes and edge cases
        - Verify fix quality and completeness

        **REGRESSION TESTING:**
        - Run full test suite to check for side effects
        - Test integration with other components
        - Verify no new issues introduced

        **EVIDENCE COLLECTION:**
        - Capture test logs for fixed scenarios
        - Take screenshots (for UI changes)
        - Document performance improvements (if applicable)

        **UPDATE RESULTS:**
        - Update docs/stories/{epic}.{story}.{title}.md
        - If still failing: Return to dev_fixes step with detailed feedback
        - If all pass: Proceed to architect review

    - step: architect_final_review
      agent: architect
      action: review implementation for architecture compliance
      reviews:
        - docs/stories/{epic}.{story}.{title}.md
        - Changed code files
        - docs/architecture/
      notes: |
        Technical Architect final review:

        **CODE REVIEW:**
        - Review implementation code for quality
        - Verify architecture patterns followed
        - Check component boundaries respected
        - Validate API design (FastAPI endpoints)
        - Review database schema changes

        **TECHNICAL DEBT ASSESSMENT:**
        - Identify any technical debt introduced
        - Assess impact on future stories
        - Document refactoring opportunities

        **PERFORMANCE REVIEW:**
        - Review performance implications
        - Check resource usage (memory, database connections)
        - Validate async/await patterns (if applicable)

        **SECURITY REVIEW:**
        - Check for security vulnerabilities
        - Validate input validation and sanitization
        - Review API key and credential handling
        - Check for SQL injection risks (DuckDB queries)

        **DECISION:**
        - Approve for PR creation
        - Request changes (return to dev with feedback)
        - Approve with notes for future improvement

    - step: sm_story_approval
      agent: sm
      action: verify story completion and alignment with PRD
      reviews:
        - docs/prd/epic-{epic}.md
        - docs/stories/{epic}.{story}.{title}.md
      notes: |
        Scrum Master verifies story completion:

        **ACCEPTANCE CRITERIA VERIFICATION:**
        - Confirm all acceptance criteria from PRD met
        - Review test results showing criterion coverage
        - Verify alignment between PRD and implementation

        **QUALITY VERIFICATION:**
        - Code follows project standards
        - Test coverage â‰¥90% maintained
        - Integration with existing features works
        - Documentation is up-to-date

        **COMPLETENESS CHECK:**
        - All tasks in story document marked complete [x]
        - No open issues or blockers
        - Technical debt documented
        - Story ready for production

        **PREPARE FOR PR:**
        - Conduct final review of story
        - Mark story as complete in tracking
        - Commit all changes to feature branch
        - Push feature branch to remote
        - Prepare PR description with story summary

    - step: create_pull_request
      agent: sm
      action: create pull request for review
      creates: pull_request
      requires: story_approved
      notes: |
        Scrum Master creates Pull Request:

        **PR PREPARATION:**
        - Ensure feature branch is up-to-date with main
        - Resolve any merge conflicts
        - Verify all commits are clean and descriptive

        **CREATE PR:**
        - Create PR from feature/story-{epic}-{story} to main
        - PR title: "Story {epic}.{story}: {story title}"
        - PR description includes:
          * Story summary from docs/stories/{epic}.{story}.{title}.md
          * Acceptance criteria checklist
          * Implementation highlights
          * Test results summary (coverage percentage)
          * Changed files list
          * Database schema changes (if applicable)
          * Breaking changes (if any)
          * Dependencies added (if any)

        **ASSIGN REVIEWERS:**
        - Assign BMad Master as primary reviewer
        - Set PR labels (epic-1, epic-2, etc.)
        - Set milestone (if applicable)
        - Link to story document in PR description

    - step: code_reviewer_pr_review
      agent: code-reviewer
      action: comprehensive PR review with approval authority
      orchestrated_by: bmad-orchestrator
      reviews: pull_request
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator assigns PR review to code-reviewer automatically.

        Code Reviewer (Alex) autonomously conducts comprehensive PR review with authority to approve/merge:

        **UNDERSTAND CONTEXT (Step 1):**
        - Read PR description and linked story document
        - Review acceptance criteria from PRD
        - Understand business logic and use cases

        **ANALYZE CHANGES (Step 2):**
        - Run git diff main...HEAD to see all changes
        - Focus on modified files, not entire codebase
        - Check for unintended changes

        **SECURITY SCAN (Step 3 - Critical):**
        - ðŸš¨ Search for exposed secrets/API keys (BLOCKS MERGE)
        - ðŸš¨ Check for SQL injection vulnerabilities (BLOCKS MERGE)
        - ðŸš¨ Validate input sanitization (BLOCKS MERGE)
        - ðŸš¨ Review authentication/authorization (BLOCKS MERGE)
        - ðŸš¨ Check for command injection risks (BLOCKS MERGE)

        **QUALITY CHECK (Step 4):**
        - Code readability and maintainability
        - Proper error handling
        - Naming conventions followed
        - No code duplication (DRY)

        **TESTING VALIDATION (Step 5):**
        - All tests passing (verify CI/test output)
        - New tests cover new functionality
        - Edge cases considered
        - Integration tests appropriate
        - Coverage â‰¥90% maintained

        **PERFORMANCE REVIEW (Step 6):**
        - Algorithmic complexity reasonable
        - Database queries optimized
        - No N+1 query problems
        - Resource usage appropriate

        **DOCUMENTATION CHECK (Step 7):**
        - Docstrings present for public APIs
        - Complex logic explained
        - README updated if needed
        - Story document complete

        **APPROVAL DECISION (Step 8):**
        - APPROVE + MERGE: No critical issues, tests pass, quality standards met
          * Use MCP GitHub tools to approve PR
          * Can merge if all checks pass
        - REQUEST CHANGES: Critical or multiple warning issues present
          * Provide detailed, actionable feedback with code examples
          * Block merge until issues resolved
        - COMMENT: Suggestions only, no blocking issues
          * Document advisory warnings and suggestions in PR comments

        **REVIEW OUTPUT FORMAT:**
        Provide constructive feedback with specific examples:
        - âœ… **Approved**: Ready to merge, excellent work
        - ðŸš¨ **CRITICAL**: Must fix (with code example showing fix)
        - âš ï¸ **WARNING**: Should fix (with explanation and suggestion)
        - ðŸ’¡ **SUGGESTION**: Consider improving (with alternative approach)

    - step: pr_changes_requested
      agent: dev
      action: address PR feedback from code reviewer
      updates: docs/stories/{epic}.{story}.{title}.md
      condition: code_reviewer_requested_changes
      notes: |
        Developer addresses code reviewer's feedback:

        **REVIEW FEEDBACK:**
        - Read code reviewer's comments carefully
        - Understand requested changes by priority (Critical/Warning/Suggestion)
        - Prioritize CRITICAL issues first
        - Address WARNING issues
        - Consider SUGGESTION improvements

        **MAKE CHANGES:**
        - Address all critical security issues
        - Fix requested code quality issues
        - Add missing tests if requested
        - Improve documentation if requested
        - Optimize performance if requested
        - Fix any security vulnerabilities

        **RESPOND TO COMMENTS:**
        - Reply to each comment
        - Explain changes made
        - Ask clarifying questions if needed
        - Provide justification for decisions

        **UPDATE PR:**
        - Commit changes to feature branch
        - Push updates to update PR automatically
        - Run tests locally before pushing (pytest + coverage)
        - Request re-review from code-reviewer

    - step: qa_verify_pr_changes
      agent: qa
      action: verify PR changes don't break functionality
      updates: docs/stories/{epic}.{story}.{title}.md
      condition: pr_changes_made
      notes: |
        QA verifies PR changes:

        **TARGETED TESTING:**
        - Test specific areas affected by PR changes
        - Focus on modified acceptance criteria
        - Test edge cases related to changes

        **REGRESSION TESTING:**
        - Run full test suite to ensure no breakage
        - Test integration with other components
        - Verify previously passing tests still pass

        **EVIDENCE COLLECTION:**
        - Capture test logs and results
        - Take screenshots (for UI changes)
        - Document any new issues found

        **UPDATE STATUS:**
        - Update test results in story document
        - Confirm to SM that changes are tested
        - Flag any new issues found (return to dev if needed)

    - step: bmad_pr_approval
      agent: bmad-master
      action: final oversight and merge PR
      merges: pull_request
      requires:
        - code_reviewer_approved
        - all_tests_passing
      condition: pr_not_yet_merged
      notes: |
        BMad Master final oversight and merge:

        **FINAL VERIFICATION:**
        - Verify code-reviewer approval completed
        - Verify all critical issues resolved
        - Confirm all tests passing
        - Check CI/CD pipeline (if configured)
        - Review final diff

        **PROJECT OVERSIGHT:**
        - Assess alignment with overall project architecture
        - Verify story contributes to epic goals
        - Note any outstanding items for future stories
        - Document any cross-story dependencies

        **MERGE PR:**
        - Merge to main branch (squash or merge commit)
        - Delete feature branch after merge
        - Tag commit with story ID (optional)

        **NOTIFY TEAM:**
        - Announce successful merge
        - Update story tracking
        - Celebrate completion

        **NOTE:** If code-reviewer already merged the PR (has merge authority),
        this step validates the merge was correct and updates tracking.

    - step: story_retrospective
      agent: sm
      action: document story completion and learnings
      updates: docs/stories/{epic}.{story}.{title}.md
      condition: story_merged
      notes: |
        Scrum Master documents story completion:

        **UPDATE STORY STATUS:**
        - Mark story as "Completed" in story document
        - Update story status in workflow tracking (this file)
        - Record completion timestamp

        **RETROSPECTIVE NOTES:**
        - Record actual vs estimated time
        - Document lessons learned:
          * What went well
          * What could be improved
          * Blockers encountered
          * Knowledge gaps identified
        - Note any technical debt created
        - Document reusable patterns discovered

        **METRICS UPDATE:**
        - Update team velocity metrics
        - Track story cycle time
        - Record test pass rates
        - Note bug escape rate

        **PREPARE FOR NEXT:**
        - Archive story document (keep in docs/stories/)
        - Update epic progress tracking
        - Check remaining stories in epic
        - Prepare team for next story

    - step: next_story_decision
      agent: sm
      action: check backlog and select next story
      orchestrated_by: bmad-orchestrator
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator automatically directs the next action based on backlog status.

        Scrum Master autonomously checks backlog:

        **AUTONOMOUS BACKLOG REVIEW:**
        - Count remaining stories in current epic (check docs/prd/epic-{epic}.md)
        - Verify dependencies met for next story (review prerequisite completions)
        - Check system capacity (always proceed unless critical failure)

        **AUTOMATED DECISION FLOW (NO USER INPUT):**
        - If more stories in current epic â†’ bmad-orchestrator AUTOMATICALLY returns to story_selection step
        - If current epic complete AND more epics remaining â†’ bmad-orchestrator proceeds to epic_completion, then returns to story_selection
        - If all 6 epics complete (all 28 MVP stories done) â†’ bmad-orchestrator proceeds to project_completion

        CONTINUOUS EXECUTION: The workflow loops automatically through all stories until complete.
        bmad-orchestrator tracks progress: Epic X of 6, Story Y of Z completed.

    - step: epic_completion
      agent: pm
      action: review and document epic completion
      orchestrated_by: bmad-orchestrator
      creates: epic_summary.md
      condition: epic_complete
      notes: |
        ORCHESTRATOR-CONTROLLED: bmad-orchestrator triggers epic completion review when all stories in epic are merged.

        Product Manager autonomously reviews epic completion:

        **AUTOMATED EPIC REVIEW:**
        - Verify all stories in epic completed (check story_progress_tracking section)
        - Review epic deliverable achieved against PRD
        - Assess epic value delivered

        **EPIC SUMMARY (AUTO-GENERATED):**
        - Create epic summary document at docs/epics/epic-{epic}-summary.md
        - Document key achievements from story implementations
        - Note technical innovations and patterns established
        - Record challenges overcome during epic

        **METRICS COLLECTION:**
        - Calculate epic completion time
        - Average test coverage across epic stories
        - Total LOC added in epic
        - Velocity metrics for epic

        **AUTONOMOUS NEXT EPIC TRANSITION:**
        - Review next epic in roadmap (Epic 1â†’2â†’3â†’4â†’5â†’6)
        - Verify readiness: prerequisites met, architecture established
        - bmad-orchestrator automatically initiates story_selection for next epic
        - NO USER APPROVAL REQUIRED: Continuous flow to next epic

    - step: project_completion
      agent: bmad-master
      action: final project review and documentation
      creates: project_summary.md
      condition: all_stories_complete
      notes: |
        BMad Master project completion:

        **PROJECT REVIEW:**
        - Review all completed stories across all epics
        - Verify all PRD requirements implemented
        - Create comprehensive project summary report

        **FINAL DELIVERABLES:**
        - Working job application automation system
        - LinkedIn job discovery operational
        - 7-agent pipeline fully functional
        - DuckDB database with job tracking
        - Gradio UI for monitoring and control
        - Automated application submission
        - Comprehensive test suite (â‰¥90% coverage)
        - Full documentation

        **METRICS SUMMARY:**
        - Total stories completed
        - Total development time
        - Team velocity trends
        - Test coverage achieved
        - Bug escape rate

        **DEPLOYMENT PREPARATION:**
        - Prepare production deployment checklist
        - Document deployment procedures
        - Create user manual
        - Plan ongoing maintenance

        **HANDOFF:**
        - Transfer to operations
        - Schedule training sessions
        - Establish support procedures

  flow_diagram: |
    ```mermaid
    graph TD
        A[Start: Prerequisites Check] --> B[sm: Select Next Story]
        B --> C[sm: Plan Story Implementation]
        C --> D{Complex Story?}
        D -->|Yes| E[analyst: Clarify Requirements]
        D -->|No| F{Architectural Changes?}
        E --> F
        F -->|Yes| G[architect: Review Design]
        F -->|No| H[dev: TDD - Write Tests First]
        G --> H

        H --> I[dev: Implement Code to Pass Tests]
        I --> J[dev: Refactor & Achieve 90% Coverage]
        J --> K[dev: Code Quality Validation]
        K --> K1{Quality Gates Pass?}
        K1 -->|No| H
        K1 -->|Yes| L[qa: Verify Coverage & Test Implementation]

        L --> M{Unit Tests Adequate?}
        M -->|No| H
        M -->|Yes| N{All Tests Pass?}
        N -->|No| O[dev: Fix Failing Tests]
        O --> P[qa: Retest Fixes]
        P --> N

        N -->|Yes| Q[architect: Final Review]
        Q --> R{Architect Approves?}
        R -->|No| O
        R -->|Yes| S[sm: Story Approval]
        S --> T[sm: Create Pull Request]
        T --> U[bmad-master: Review PR]

        U --> V{PR Approved?}
        V -->|Changes Requested| W[dev: Address PR Feedback]
        W --> X[qa: Verify PR Changes]
        X --> U

        V -->|Approved| Y[bmad-master: Merge to Main]
        Y --> Z[sm: Story Retrospective]
        Z --> AA{More Stories?}

        AA -->|Yes, Same Epic| B
        AA -->|Yes, Next Epic| AB[pm: Epic Completion]
        AB --> B
        AA -->|No| AC[bmad-master: Project Completion]

        style A fill:#FFE4B5
        style B fill:#87CEEB
        style C fill:#87CEEB
        style E fill:#DDA0DD
        style G fill:#98FB98
        style H fill:#FF6B6B
        style I fill:#51CF66
        style J fill:#4C6EF5
        style K fill:#FFA94D
        style L fill:#F0E68C
        style O fill:#ADD8E6
        style P fill:#F0E68C
        style Q fill:#98FB98
        style S fill:#87CEEB
        style T fill:#87CEEB
        style U fill:#FFB6C1
        style W fill:#ADD8E6
        style X fill:#F0E68C
        style Y fill:#FFB6C1
        style Z fill:#87CEEB
        style AB fill:#DDA0DD
        style AC fill:#90EE90
    ```

  agent_responsibilities:
    orchestration_control: |
      The bmad-orchestrator controls agent activation and manages all handoffs:

      AGENT ACTIVATION SEQUENCE (per story):
        1. Scrum Master (SM) - Prerequisites, Selection, Planning, Approval, PR Creation, Retrospective
        2. Business Analyst (Analyst) - Requirements Clarification [CONDITIONAL]
        3. Technical Architect (Architect) - Architecture Review [CONDITIONAL], Final Review
        4. Developer (Dev) - TDD Implementation, Quality Validation, Fixes
        5. Code Reviewer (code-reviewer) - Security Scan, Code Quality Review (after Dev)
        6. QA Tester (QA) - Testing Cycle, Retesting, PR Verification
        7. Code Reviewer (code-reviewer) - PR Review, Approval, Potential Merge
        8. BMad Master - Final Oversight, Merge Validation, Project Completion

      AUTOMATIC HANDOFF PROTOCOL:
        - Agents complete their task and signal completion to orchestrator
        - bmad-orchestrator validates completion criteria
        - bmad-orchestrator activates next agent in sequence
        - No user confirmation required for any handoff
        - Failed quality gates trigger automatic retry with previous agent
        - All agents operate autonomously within their scope

      CONDITIONAL AGENT ACTIVATION:
        - Analyst: Triggered if story complexity threshold exceeded
        - Architect: Triggered if architectural changes detected
        - Dev Fixes: Triggered automatically if code-reviewer or QA finds issues
        - PR Changes: Triggered automatically if code-reviewer requests changes

      CODE-REVIEWER DUAL ROLE:
        - First Review: After code quality validation, before QA (security & quality scan)
        - Second Review: After PR creation (comprehensive PR review with approval authority)
        - Has authority to approve, request changes, and merge PRs
        - Enforces security-first principles and quality standards

      PARALLEL OPERATIONS (where applicable):
        - None: This workflow is strictly sequential per story
        - However, multiple agents may prepare for their steps concurrently

    scrum_master:
      - Select next story from PRD epics
      - Review story acceptance criteria from PRD
      - Create feature branches for stories
      - Create detailed user stories in docs/stories/
      - Create pull requests to main branch
      - Story completion tracking and retrospectives
      - Velocity monitoring across all epics
      - Team coordination and blocker removal

    product_manager:
      - Epic completion reviews and summaries
      - Stakeholder demo preparation
      - Epic kickoff planning
      - Value delivery assessment

    business_analyst:
      - Requirements clarification for complex stories
      - Edge case identification
      - Business logic validation
      - Integration point analysis
      - Risk analysis for complex features

    developer:
      - Follow Test-Driven Development (TDD) methodology
      - Achieve minimum 90% code coverage
      - Implement all acceptance criteria from PRD
      - Python 3.11+ development (FastAPI, pytest)
      - Database operations (DuckDB)
      - Redis queue integration (RQ workers)
      - Agent implementation (BaseAgent, 7 agents)
      - Claude API integration
      - LinkedIn MCP server integration
      - Document generation (python-docx)
      - Code quality validation (ruff, black, mypy)
      - Unit and integration testing
      - Fix issues from QA feedback
      - Address PR review comments

    technical_architect:
      - Review technical design and architecture
      - System design and component architecture
      - Database schema validation
      - API design review (FastAPI patterns)
      - Integration patterns (MCP, Redis, Claude)
      - Performance considerations
      - Security review
      - Final implementation review
      - Technical debt assessment

    qa_tester:
      - Verify unit test coverage from Dev (â‰¥90%)
      - Validate all acceptance criteria from PRD
      - Integration testing:
        * FastAPI endpoint testing
        * Database operations (DuckDB)
        * Redis queue operations
        * Agent pipeline execution
        * LinkedIn job discovery
        * CV/CL document generation
        * Duplicate detection algorithms
        * Form submission automation
        * Gradio UI functionality
      - Document criterion-by-criterion results
      - Regression testing for existing features
      - Performance validation
      - Retest fixes after dev changes
      - Verify PR changes don't break functionality

    code_reviewer:
      - Security scan after code implementation (first checkpoint)
      - Code quality review before QA testing
      - Comprehensive PR review (second checkpoint)
      - Vulnerability detection (secrets, injection, XSS)
      - Performance analysis (algorithmic complexity, N+1 queries)
      - Test coverage validation
      - Documentation completeness check
      - PR approval authority
      - Request changes with actionable feedback
      - Merge authority (can merge approved PRs)
      - Constructive feedback with code examples
      - Risk-based prioritization (Critical/Warning/Suggestion)

    bmad_master:
      - Final project oversight
      - Cross-story architecture alignment
      - Epic-level quality assurance
      - PR merge validation (if code-reviewer merged)
      - Final merge authority (if not yet merged)
      - Project completion review
      - Epic completion coordination
      - Strategic technical direction

  quality_gates:
    before_code_review:
      - All unit tests written using TDD approach
      - Unit test coverage â‰¥90% verified
      - Coverage report generated and documented
      - All acceptance criteria have corresponding tests
      - Code quality validation passed (ruff, black, mypy)
      - Code committed with descriptive messages

    before_qa_handoff:
      - Code review security scan passed
      - No critical security issues (secrets, injection risks)
      - Code quality review completed
      - Performance concerns addressed
      - Code-reviewer approved for QA testing

    before_pr_creation:
      - All acceptance criteria met and tested
      - All unit tests passing (100% pass rate)
      - Code coverage â‰¥90% maintained
      - Integration tests passing
      - Code follows Python best practices
      - Architect final review approved
      - Story marked as Done by SM
      - All tasks marked complete [x] in docs/stories/{epic}.{story}.{title}.md

    before_pr_merge:
      - BMad Master approval received
      - All CI/CD checks pass (if configured)
      - No merge conflicts with main
      - All requested changes addressed
      - QA verification complete for PR changes
      - Documentation updated

    before_next_story:
      - Previous story fully merged to main
      - Retrospective documented
      - No blocking issues
      - Team capacity available
      - Dependencies for next story met

  handoff_prompts:
    sm_to_analyst: |
      Story {{epic}}.{{story}} selected for implementation.
      Story appears complex and needs requirements clarification.
      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md
      PRD reference: docs/prd/epic-{{epic}}.md
      Please review and clarify requirements, edge cases, and business logic.

    analyst_to_architect: |
      Story {{epic}}.{{story}} requirements clarified.
      Architectural changes needed for this story.
      Please review technical design and provide architecture guidance.
      Updated story: docs/stories/{{epic}}.{{story}}.{{title}}.md

    sm_to_dev: |
      Story {{epic}}.{{story}} ready for implementation.
      PRD: docs/prd/epic-{{epic}}.md
      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md
      Acceptance criteria: {{criteria_count}} items
      Feature branch: feature/story-{{epic}}-{{story}}

      Please implement using Test-Driven Development (TDD):
      1. Write tests first (RED phase)
      2. Implement code to pass tests (GREEN phase)
      3. Refactor for quality (REFACTOR phase)
      4. Achieve â‰¥90% code coverage

      Technology focus:
      {{#if foundation_epic}}
      - FastAPI application structure
      - DuckDB database setup
      - Redis + RQ queue system
      - Configuration loading (YAML)
      - LinkedIn MCP integration
      {{/if}}
      {{#if agent_epic}}
      - BaseAgent abstract class
      - Agent-specific implementations
      - Claude API integration
      - Checkpoint/resume system
      - Document generation (CV/CL)
      {{/if}}
      {{#if duplicate_epic}}
      - Similarity algorithms
      - Duplicate detection logic
      - Database duplicate tracking
      {{/if}}
      {{#if submission_epic}}
      - Email submission
      - Playwright form automation
      - Application tracking
      {{/if}}
      {{#if ui_epic}}
      - Gradio dashboard components
      - Real-time data display
      - User controls and filters
      {{/if}}

    dev_to_code_reviewer: |
      Story {{epic}}.{{story}} implementation complete with TDD and code quality validation passed.

      **Test Coverage:**
      - Unit test coverage: {{coverage_percentage}}%
      - Test files created: {{test_file_count}}
      - All unit tests passing: {{unit_test_status}}

      **Code Quality:**
      - Linter (ruff): Passed
      - Formatter (black): Passed
      - Type checker (mypy): Passed

      **Implementation:**
      - Changed files: {{file_list}}
      - Acceptance criteria implemented: {{criteria_count}}
      - Database schema changes: {{schema_changes}}
      - API endpoints added/modified: {{api_endpoints}}

      **Ready for Code Review:**
      Please perform security scan and code quality review before QA testing.
      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    code_reviewer_to_qa: |
      Story {{epic}}.{{story}} code review and security scan complete - APPROVED for QA testing.

      **Security Scan Results:**
      - No exposed secrets/API keys found âœ…
      - No SQL injection vulnerabilities âœ…
      - No command injection risks âœ…
      - Input validation implemented âœ…

      **Code Quality:**
      - Code readability: Excellent
      - Error handling: Proper
      - Performance: Acceptable
      - Test coverage: {{coverage_percentage}}% âœ…

      **Warnings/Suggestions (if any):**
      {{warnings_list}}

      **Ready for QA Testing:**
      Please verify unit test coverage first, then perform integration and acceptance testing.
      Test each acceptance criterion from PRD.
      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    code_reviewer_to_dev: |
      Story {{epic}}.{{story}} code review found CRITICAL issues - returning to Dev.

      **ðŸš¨ CRITICAL Issues (Must Fix Before QA):**
      {{critical_issues_list}}

      **âš ï¸ Warnings (Should Fix):**
      {{warning_issues_list}}

      **ðŸ’¡ Suggestions (Consider):**
      {{suggestion_list}}

      **Action Required:**
      - Fix all critical security and quality issues
      - Address warning items
      - Consider suggested improvements
      - Re-run tests locally
      - Request code review again when ready

      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    qa_to_dev_fixes: |
      Testing found {{failure_count}} failing tests for story {{epic}}.{{story}}.

      **Failed Acceptance Criteria:**
      {{failure_summary}}

      **Details:**
      See full test results in docs/stories/{{epic}}.{{story}}.{{title}}.md

      **Action Required:**
      - Fix failing tests and issues
      - Re-run unit tests locally
      - Update story document with fix notes
      - Notify QA when ready for retest

    qa_to_architect: |
      All tests passing for story {{epic}}.{{story}}.

      **Test Summary:**
      - Unit tests: {{unit_test_count}} passing
      - Integration tests: {{integration_test_count}} passing
      - Coverage: {{coverage_percentage}}%
      - All acceptance criteria validated

      Ready for architecture final review.
      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    architect_to_sm: |
      Architecture review complete for story {{epic}}.{{story}}.

      **Review Status:** {{approval_status}}

      {{#if approved}}
      - Code quality: Excellent
      - Architecture compliance: Verified
      - Performance: Acceptable
      - Security: No issues found
      - Technical debt: {{technical_debt_notes}}

      Ready for SM approval and PR creation.
      {{/if}}

      {{#if changes_requested}}
      - Changes required: {{change_summary}}
      - Return to Dev for modifications
      {{/if}}

    sm_to_code_reviewer_pr: |
      Pull Request created for story {{epic}}.{{story}}.

      **PR Details:**
      - PR #: {{pr_number}}
      - Branch: feature/story-{{epic}}.{{story}} â†’ main
      - Title: Story {{epic}}.{{story}}: {{story_title}}

      **Summary:**
      - Acceptance criteria: {{criteria_count}} completed
      - Test status: All passing
      - Coverage: {{coverage_percentage}}%
      - Files changed: {{files_changed_count}}
      - Security scan: Passed (pre-QA review)
      - QA testing: All acceptance criteria validated

      **Ready for PR Review:**
      Please conduct comprehensive PR review following 8-step workflow:
      1. Understand context (read story, PRD, business logic)
      2. Analyze changes (git diff, check for unintended changes)
      3. Security scan (secrets, injection, sanitization)
      4. Quality check (readability, error handling, DRY)
      5. Testing validation (coverage, edge cases)
      6. Performance review (complexity, queries, resources)
      7. Documentation check (docstrings, README)
      8. Approval decision (approve/request changes/comment)

      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    code_reviewer_to_dev_pr_changes: |
      PR #{{pr_number}} requires changes for story {{epic}}.{{story}}.

      **ðŸš¨ CRITICAL Issues (Block Merge):**
      {{critical_issues_list}}

      **âš ï¸ WARNING Issues (Should Fix):**
      {{warning_issues_list}}

      **ðŸ’¡ SUGGESTIONS (Consider):**
      {{suggestion_list}}

      **Priority:** {{priority}}

      **Action Required:**
      - Fix all CRITICAL issues (security, breaking changes, tests)
      - Address WARNING issues (code quality, performance)
      - Consider SUGGESTION improvements
      - Reply to each review comment with explanations
      - Push updates to feature branch
      - Request re-review from code-reviewer when complete

      Branch: feature/story-{{epic}}.{{story}}

    code_reviewer_to_bmad_approved: |
      âœ… PR #{{pr_number}} APPROVED for story {{epic}}.{{story}}.

      **Code Review Summary:**
      - Security scan: âœ… No critical vulnerabilities
      - Code quality: âœ… Meets standards
      - Test coverage: âœ… {{coverage_percentage}}%
      - Performance: âœ… Acceptable
      - Documentation: âœ… Complete

      **Warnings Documented (if any):**
      {{warnings_summary}}

      **Approval Status:** APPROVED
      - All critical issues resolved
      - Quality standards met
      - Ready for merge

      **Next Step:**
      BMad Master for final oversight and merge to main.

      Story document: docs/stories/{{epic}}.{{story}}.{{title}}.md

    bmad_to_team_merged: |
      âœ… PR #{{pr_number}} merged to main!

      **Story Complete:** {{epic}}.{{story}} - {{story_title}}

      **Highlights:**
      - Coverage achieved: {{coverage_percentage}}%
      - Test pass rate: 100%
      - Feature branch deleted

      **Next Steps:**
      - Story retrospective by SM
      - Prepare for next story

      Great work team! ðŸŽ‰

    sm_to_team_next: |
      Story {{epic}}.{{story}} retrospective complete.

      **Lessons Learned:**
      - What went well: {{went_well}}
      - What to improve: {{to_improve}}
      - Velocity: {{velocity_metrics}}

      **Next Story:** {{next_epic}}.{{next_story}} - {{next_story_title}}

      ORCHESTRATOR ACTION: bmad-orchestrator automatically returning to story_selection phase.
      NO USER CONFIRMATION NEEDED: Proceeding to next story implementation.

    pm_epic_complete: |
      ðŸŽ¯ Epic {{epic}} Complete!

      **Epic:** {{epic_title}}
      **Stories Completed:** {{story_count}}
      **Epic Value:** {{epic_value_delivered}}

      **Key Achievements:**
      {{achievements_summary}}

      **Next Epic:** {{next_epic}} - {{next_epic_title}}

      ORCHESTRATOR ACTION: bmad-orchestrator automatically initiating next epic.
      NO USER APPROVAL REQUIRED: Continuous execution to Epic {{next_epic}}.

    project_complete: |
      ðŸŽŠ PROJECT COMPLETE! ðŸŽŠ

      **Job Application Automation System - Fully Implemented**

      **All Epics Completed:**
      - Epic 1: Foundation âœ…
      - Epic 2: Core Agents (7 agents) âœ…
      - Epic 3: Duplicate Detection âœ…
      - Epic 4: Application Submission âœ…
      - Epic 5: Gradio UI âœ…
      - Epic 6: Testing & Refinement âœ…

      **Final Metrics:**
      - Total stories completed: {{story_count}}
      - Average coverage: {{avg_coverage}}%
      - Project velocity: {{velocity_metrics}}
      - Development time: {{total_time}}

      **Deliverables Ready:**
      - âœ… LinkedIn job discovery operational
      - âœ… 7-agent pipeline fully functional
      - âœ… DuckDB database with job tracking
      - âœ… Automated CV/CL generation
      - âœ… Duplicate detection system
      - âœ… Application submission automation
      - âœ… Gradio monitoring UI
      - âœ… Comprehensive test suite (â‰¥90%)
      - âœ… Full documentation

      **Ready for Production Deployment! ðŸš€**

  decision_guidance:
    orchestration_flow_control: |
      BMAD-ORCHESTRATOR CONTINUOUS EXECUTION MODEL:

      The bmad-orchestrator maintains a persistent execution loop that continues
      until all 6 epics (28 total stories) are complete. No user interaction is
      required at any point in the workflow.

      EXECUTION STATE MACHINE:
        State: {current_epic: int, current_story: int, total_completed: int}
        Initial: {current_epic: 1, current_story: 1, total_completed: 0}
        Final: {current_epic: 6, current_story: 4, total_completed: 28}

      LOOPING MECHANISM:
        OUTER LOOP (Epic Level):
          FOR epic IN [1, 2, 3, 4, 5, 6]:
            INNER LOOP (Story Level):
              FOR story IN epic.stories:
                EXECUTE story_workflow_cycle(epic, story)
                IF story_workflow_cycle.status == MERGED:
                  total_completed += 1
                  CONTINUE to next story
                ELSE:
                  RETRY story_workflow_cycle until MERGED
              END FOR
            EXECUTE epic_completion_review(epic)
            IF epic < 6:
              CONTINUE to next epic (NO USER APPROVAL)
          END FOR
        EXECUTE project_completion_review()
        TERMINATE with success

      STORY WORKFLOW CYCLE (Executed for each story):
        1. prerequisites_check â†’ 2. story_selection â†’ 3. story_planning â†’
        4. [conditional: requirements_clarification] â†’
        5. [conditional: architecture_review] â†’ 6. story_implementation â†’
        7. code_quality_validation â†’ 8. code_review_security_scan â†’
        9. [conditional loop: dev_fixes if code review fails] â†’
        10. qa_testing_cycle â†’
        11. [conditional loop: dev_fixes â†’ qa_retest until pass] â†’
        12. architect_final_review â†’ 13. sm_story_approval â†’
        14. create_pull_request â†’ 15. code_reviewer_pr_review â†’
        16. [conditional loop: pr_changes_requested â†’ qa_verify_pr_changes until approved] â†’
        17. bmad_pr_approval â†’ 18. story_retrospective â†’
        19. next_story_decision â†’ RETURN to step 2 OR proceed to epic_completion

      AUTONOMOUS DECISION LOGIC:
        - All conditionals are evaluated automatically by bmad-orchestrator
        - No user prompts or confirmations at any decision point
        - Failed quality gates trigger automatic retry loops
        - Story sequence is strictly ordered (1.1 â†’ 1.2 â†’ ... â†’ 6.4)
        - Epic transitions happen automatically when all stories complete
        - Workflow only terminates when all 28 stories are merged to main

    when_to_use:
      - Multiple stories across 6 epics need sequential development
      - Python/FastAPI backend development with LLM integration
      - Multi-agent system requiring careful testing
      - Quality gates are critical for production readiness
      - Team requires clear handoffs between specialists
      - PR review process is mandatory
      - Story-by-story tracking needed for complex system
      - FULLY AUTONOMOUS execution required without user intervention

    benefits:
      - Clear accountability at each step
      - No story left incomplete
      - Continuous quality validation with 90% coverage
      - Clean git history with feature branches
      - Predictable velocity across epics
      - Reduced merge conflicts
      - Specialist expertise applied at right time
      - Architecture compliance enforced
      - High-quality automated job application system
      - ZERO MANUAL INTERVENTION: Runs until all epics complete
      - CONTINUOUS PROGRESS: 24/7 development cycle capability

    prerequisites:
      - Python 3.11+ development environment
      - Git repository with main branch
      - All BMad agents available (sm, dev, qa, architect, analyst, pm)
      - PRD epics in docs/prd/ directory
      - Architecture docs in docs/architecture/
      - Clear acceptance criteria per story
      - Testing framework: pytest with coverage
      - Code quality tools: ruff, black, mypy
      - Redis server for job queue
      - DuckDB for database
      - LinkedIn MCP server configured
      - Anthropic Claude API access

  automation_opportunities:
    ci_cd_integration:
      - Automated pytest runs on PR creation
      - Coverage report generation and validation
      - Code quality checks (ruff, black, mypy)
      - Security scanning for dependencies
      - Automated deployment to staging
      - Integration testing with test jobs
      - Performance testing for agent pipeline
      - Database migration testing

    notification_system:
      - PR status updates
      - Test result summaries
      - Coverage threshold alerts
      - Merge notifications
      - Blocker alerts
      - Story completion celebrations

    metrics_tracking:
      - Story cycle time per epic
      - Test pass rates over time
      - PR review time
      - Bug escape rate
      - Team velocity trends
      - Agent performance metrics
      - Test coverage trends
      - Code quality scores

  story_progress_tracking:
    epic_1_foundation:
      total_stories: 5
      stories:
        - "1.1: Project Setup and Dependencies"
        - "1.2: Configuration System"
        - "1.3: DuckDB Schema Implementation"
        - "1.4: LinkedIn Job Poller (Basic)"
        - "1.5: Job Queue System"

    epic_2_core_agents:
      total_stories: 8
      stories:
        - "2.1: Agent Base Class and Infrastructure"
        - "2.2: Job Matcher Agent"
        - "2.3: Salary Validator Agent"
        - "2.4: CV Tailor Agent"
        - "2.5: Cover Letter Writer Agent"
        - "2.6: QA Agent"
        - "2.7: Orchestrator Agent"
        - "2.8: Checkpoint System"

    epic_3_duplicate_detection:
      total_stories: 3
      stories:
        - "3.1: Tier 1 Exact Duplicate Detection"
        - "3.2: Tier 2 Fuzzy Duplicate Detection"
        - "3.3: Duplicate Group Management"

    epic_4_application_submission:
      total_stories: 3
      stories:
        - "4.1: Email Submission Handler"
        - "4.2: Web Form Submission Handler"
        - "4.3: Submission Status Tracking"

    epic_5_gradio_ui:
      total_stories: 5
      stories:
        - "5.1: Gradio Dashboard Setup"
        - "5.2: Job Queue Monitor"
        - "5.3: Application Review Interface"
        - "5.4: Document Preview"
        - "5.5: Manual Controls"

    epic_6_testing_refinement:
      total_stories: 4
      stories:
        - "6.1: End-to-End Testing"
        - "6.2: Performance Optimization"
        - "6.3: Error Handling Improvements"
        - "6.4: Documentation Finalization"

    total_mvp_stories: 28
    completion_tracking: "Track in this file as stories complete"

  configuration_files:
    - config/search.yaml
    - config/agents.yaml
    - config/platforms.yaml
    - config/similarity.yaml
    - .mcp.json
    - requirements.txt
    - .env.example

  testing_strategy:
    unit_testing:
      - Framework: pytest
      - Coverage minimum: 90%
      - Mocking: unittest.mock or pytest-mock
      - Fixtures: pytest fixtures for common test data
      - Test structure: Arrange-Act-Assert pattern

    integration_testing:
      - FastAPI TestClient for endpoint testing
      - DuckDB in-memory database for testing
      - Mock Redis for queue testing
      - Mock Claude API responses
      - Mock LinkedIn MCP responses

    end_to_end_testing:
      - Full agent pipeline execution
      - Real job data processing (test set)
      - Document generation validation
      - Gradio UI interaction testing
      - Submission workflow testing (test mode)
